# 分布式锁
分布式锁是一种用于在分布式系统中控制对共享资源的访问的技术。在分布式环境中，由于多个节点同时访问共享资源，需要一种机制来保证同一时间只有一个节点可以对资源进行操作，以避免数据不一致或竞争条件的发生。与单体应用不同的是，分布式系统中竞争共享资源的最小粒度从线程升级成了进程。
## 特点
1. 在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行
2.  高可用，高性能的获取锁与释放锁
3. 具备可重入特性
4. 具备锁失效机制，即自动解锁，防止死锁
5. 具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败
## 实现方式
1. **基于数据库的分布式锁**：利用数据库的事务特性和行级锁来实现分布式锁。通过在数据库中创建一个锁表，利用数据库的唯一性约束或者行级锁来保证同一时间只有一个节点可以获得锁。
2. **基于缓存的分布式锁**：利用分布式缓存系统（如Redis）来实现分布式锁。通过在缓存中设置一个特定的键值对，利用缓存的原子性操作（如 SETNX）来保证同一时间只有一个节点可以获得锁。
3. **基于ZooKeeper的分布式锁**：利用ZooKeeper分布式协调服务来实现分布式锁。通过在ZooKeeper的节点上创建临时有序节点，并利用节点的顺序特性来实现锁的竞争和释放。
4. **基于分布式算法的分布式锁**：如基于Paxos、Raft等分布式一致性算法来实现分布式锁。这种方式通常需要引入额外的复杂性，但能够提供更强的一致性保证。
# 基于redis实现分布式锁
## 基于set命令
1. **加锁**：使用setnx进行加锁，当该指令返回1时，说明成功获得锁
2. **解锁**：当得到锁的线程执行完任务之后，使用del命令释放锁，以便其他线程可以继续执行setnx命令来获得锁
	- 存在的问题：假设线程获取了锁之后，在执行任务的过程中挂掉，来不及显示地执行del命令释放锁，那么竞争该锁的线程都会执行不了，产生死锁的情况。
	- 解决方案：设置锁超时时间
3. **设置锁超时时间**：setnx 的 key 必须设置一个超时时间，以保证即使没有被显式释放，这把锁也要在一定时间后自动释放。可以使用expire命令设置锁超时时间
	- 存在问题：setnx 和 expire 不是原子性的操作，假设某个线程执行setnx 命令，成功获得了锁，但是还没来得及执行expire 命令，服务器就挂掉了，这样一来，这把锁就没有设置过期时间了，变成了死锁，别的线程再也没有办法获得锁了。
	- 解决方案：redis的set命令支持在获取锁的同时设置key的过期时间
4. **使用set命令加锁并设置锁过期时间**：set <lock.key> <lock.value> nx ex  \<expireTime>
	- 存在问题：假如线程A成功得到了锁，并且设置的超时时间是 30 秒。如果某些原因导致线程 A 执行的很慢，过了 30 秒都没执行完，这时候锁过期自动释放，线程 B 得到了锁。 随后，线程A执行完任务，接着执行del指令来释放锁。但这时候线程 B 还没执行完，线程A实际上删除的是线程B加的锁。
	- 解决方案：在 del 释放锁之前做一个判断，验证当前的锁是不是自己加的锁。在加锁的时候把当前的线程 ID 当做value，并在删除之前验证 key 对应的 value 是不是自己线程的 ID。但是，这样做其实隐含了一个新的问题，get操作、判断和释放锁是两个独立操作，不是原子性。对于非原子性的问题，我们可以**使用Lua脚本**来确保操作的原子性
5. **锁续期**：虽然步骤4避免了线程A误删掉key的情况，但是同一时间有 A，B 两个线程在访问代码块，仍然是不完美的。可以让获得锁的线程开启一个守护线程，用来给快要过期的锁“续期”。（类似redisson的实现）
