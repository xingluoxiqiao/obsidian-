# **集合：**
collection，map
arraylist，linkedlist
hashset，treeset
hashmap，treemap各自的特点
hashmap和arraylist的扩容
# **多线程：**
保证并发的三大特性：原子性，可见性，有序性
volatile保证可见性和有序性：保证不同线程对变量操作的可见性，修改时其他线程是立即可见的；禁止指令重排序，添加一个内存屏障，禁止在内存屏障前后的指令执行重排序优化
synchronized保证原子性
synchronized和lock区别：关键字和接口；lock功能多（公平锁，可打断，可超时）；没有竞争时synchronizd有优化，有竞争时lock有优化；synchronizd退出自动释放，lock手动释放
偏向锁，轻量级锁，重量级锁（单线程、线程交替、多线程竞争）
synchronized底层：java对象头中的监视器（等待队列，阻塞队列，当前持有线程（唯一））
创建线程：继承Thread类，实现callable，实现runnable，线程池创建
线程池七大参数：最大线程数，核心线程数，非核心线程存活时间，时间单位，等待队列，线程工厂，拒绝策略（抛异常，由调用者执行任务，丢弃当前任务，丢弃最早排队任务）
线程池四种创建方式：可缓存（newcachedthreadpool），定长(newfixed)，周期性（newscheduled）,唯一工作线程（new single）
不用executor：默认长度是int最大值，可能堆积大量请求导致内存溢出
线程六状态：新建，就绪，运行，阻塞，等待，限时等待
wait，sleep，run，start，notify，interrupt
CAS：compare and swap 乐观锁，先判断再更新
AQS：类AbstractQuenedSynchronizer，state锁是否获取，fifo阻塞队列，当前获取锁的线程
ThreadLocal：资源对象线程隔离（每个线程有自己的资源空间）；线程内资源共享（前存后取）；内存泄露：key是弱引用，value是强引用，需要主动remove
强，软，弱，虚引用
#  **IO：**
分为字符流和字节流
字符流有reader和wirter filereader，filewriter
字节流有inputstream，outputstream
转换流有inputstreamreader，outputstreamwriter
缓冲流：底层有缓冲区，默认8192字节
序列化流：实现serilizable接口
# **JVM：**
java内存结构：线程私有（程序计数器，虚拟机栈，本地方法栈），线程共享（**方法区，堆**）
依次作用：存放程序中断所处的行号，存放栈帧（局部变量表，操作数表，动态链接，方法出口），java源码中的native方法，存放类、常量、静态变量、编译后代码等，存放对象实例，
java堆结构：新生代（两个大小严格相同的区域（幸存者）和 伊甸园1.1.8），老年代
判断对象存活的方法：引用计数，可达性分析（gcroot：常量引用对象，类静态引用对象）
对象晋升过程：minorGC，majorGC，fullGC
垃圾回收策略：引用计数，标记整理，标记清除，复制
垃圾收集器：CMS(采用标记清除算法，目标是最短回收停顿，运行在老年代，可以并发收集),G1（采用标记整理+复制算法，使用可达性分析法，注重响应速度，支持并发）
JMM（java memory model）：所有变量存在主存中（线程共享），每个线程有自己的工作空间，需要操作变量时从主存中复制到自己的工作区，各线程工作内存相互隔离；屏蔽了硬件和操作系统的内存访问差异，实现了java在各平台下实现一致的内存访问效果
四种类加载器：启动，应用，扩展，自定义
类加载过程：**加载**（类加载器将文件加载为堆中java对象），
					 **连接**（验证（jvm规范，class文件格式），准备（static变量在方法区中分配内存），解析（虚拟机常量池符号引用转换为直接引用）），
					 **初始化**（为静态变量赋初值）
双亲委派：类加载器收到加载请求时，先向自己的父加载器传递，父加载器无法完成请求时才尝试自己加载；好处：避免重复加载，保证核心api库不会随意被更改
# **设计模式：**
1. **单例模式：**
    - 目的：确保一个类只有一个实例，并提供全局访问点。
    - 实现：通过私有化构造方法，提供一个静态方法返回唯一实例。
2. **工厂模式：**
    - 目的：将对象的创建和使用分离，通过工厂方法创建对象。
    - 实现：定义一个接口，多个实现类，由工厂类根据条件创建具体实例。
3. **策略模式：**
    - 目的：定义一系列算法，封装每个算法，并使它们可互换。
    - 实现：创建一个策略接口，多个实现类代表不同算法，Context类使用其中之一。
4. **责任链模式：**
    - 目的：将请求的发送者和接收者解耦，多个对象按顺序处理请求。
    - 实现：每个处理者持有下一个处理者的引用，请求依次传递，直到有处理者处理为止。
spring中使用的设计模式
1. **工厂模式（Factory Pattern）：**
    - Spring中通过工厂模式创建和管理Bean对象，尤其是通过ApplicationContext容器进行Bean的实例化和管理。
2. **单例模式（Singleton Pattern）：**  
    - Spring的默认作用域是单例（Singleton），确保在容器中每个Bean只有一个实例。
3. **代理模式（Proxy Pattern）：**
    - Spring AOP（面向切面编程）通过代理模式实现，允许在方法执行前、后或异常抛出时注入额外的行为。
4. **观察者模式（Observer Pattern）：**
    - Spring事件机制基于观察者模式，通过事件监听器监听并响应应用中的事件。
5. **模板方法模式（Template Method Pattern）：**
    - 在Spring中，JdbcTemplate是一个典型的使用模板方法设计模式的类，它定义了执行SQL语句的通用步骤，而具体的实现留给子类。
6. **策略模式（Strategy Pattern）：**
    - Spring的资源访问策略（ResourceLoader）和缓存策略（Cache）等功能使用了策略模式。
7. **装饰者模式（Decorator Pattern）：**
    - Spring中的AOP就是通过装饰者模式来实现的，通过在原有业务逻辑前后加入横切逻辑。
8. **适配器模式（Adapter Pattern）：**
    - Spring MVC中的HandlerAdapter就是使用适配器模式，将不同的处理器适配到统一的处理器接口。

# **开发框架：**
IOC：控制反转，将对象的创建和调用从程序员手中交由ioc容器管理，降低对象间的依赖关系
AOP：面向切面编程，将与业务无关但对多个对象产生影响的公共行为和逻辑抽取公共模块复用，降低耦合；事务处理，公共日志保存等（通知+切点表达式）
spirngAOP的实现：使用的动态代理
jdk动态代理：反射，调用porxy.newProxyInstance返回代理对象（参数：类加载器，被代理类实现的接口数组，增强方法的InvocaHandler实现类），要求被代理类实现（任意）接口，默认，
cglib动态代理：创建被代理对象的子类，覆盖其中的方法，被代理对象没有实现接口时使用
Bean的生命周期：实例化，属性复制，初始化，销毁（除此之外，还可以通过实现aware接口或后置处理器来扩展）
从BeanDefinition类中获取bean的信息，使用构造函数实例化bean，通过依赖注入或者set方法进行属性赋值，Initialization、init-method等方法进行初始化，销毁
**循环依赖**：三级缓存解决（一级：已经初始化完成的bean；二级：生命周期还未走完的半成品bean；三级：缓存ObjectFactory对象工厂）
流程（假设AB循环依赖）：
1.A实例化，创建ObjectFactory对象工厂存入三级缓存
2.A初始化，需要B，B开始创建，B实例化，创建objectFactory对象工厂
3.B初始化过程中需要A，从三级缓存中A的对象工厂获取A的普通或者代理对象（这个对象存入二级缓存），B从二级缓存中获取A的对象完成属性注入，B创建成功，存入一级缓存
4.A正常注入创建成功，存入一级缓存
5.二级缓存中的A的临时对象清除
springboot自动配置过程：
启动类上注解springbootApplication包含三个注解
springbootConfiguration、EnableAutoConfiguration、ComponentScan
其中EnableAutoConfiguration用于开启自动配置，它通过import注解导入对应的配置选择器
内部读取了该项目和该项目引用的jar包下的classpath路径下的METE-INF/spring.factories文件中配置的类的全类名，这些配置类所定义的bean根据条件注解指定的条件决定是否注入spring容器
# **Mysql：**
执行引擎：InnoDB、MyISAM（事务外键行级锁）
事务四大特性：原子（undolog，记录需要回滚的日志信息，回滚时撤销已执行的sql），
						 一致（目的，共同保证），
						 隔离（MVCC），
						 持久（redolog和内存，修改数据时内存和redolog会记录操作，宕机时修复）
事务隔离级别：读未提交、读已提交、可重复读（快照读，读的是当前可见版本，不保证强一致性，当前读，读的是数据最新版本，返回的记录会上锁，保证其他事务不会并发修改）、串行化（脏读、不可重复读、幻读）
MVCC：多版本并发控制，每个事务都有自己的版本，实现：undolog，readview，隐藏字段（事务id，回滚指针）
记录数据历史版本，事务进行快照读时动态生成的视图控制哪个历史版本对当前事务可见，
最近修改记录的事务id，配合undolog指向数据的上一个版本
索引：主键索引、唯一索引、复合索引、普通索引、（全文索引）
最左匹配原则
聚簇索引和二级索引（非聚簇索引）B+树
覆盖索引：索引包含要查询的全部字段
索引失效：违反最左匹配，模糊查询%开头，运算，类型转换，全表比索引快
B树和B+树：
B树所有节点存储数据，进行范围查询时要进行多次回溯
B+树只有叶子节点存储数据，采用双向链表，范围查询可直接遍历不需要回溯
**锁：**
行级锁，表级锁，间隙锁（锁住表的一个区间）
共享锁（读锁），排他锁（写锁）
# **Redis：**
快：基于C语言，内存操作，数据结构简单，执行命令单线程，io多路复用
数据类型：string，list，set，sortedset，hash
底层数据结构：SDS，ziplist，skiplist，bitmap
缓存击穿，缓存穿透，缓存雪崩
数据持久化策略：RDB（父进程fork子进程生成快照文件，恢复速度快，但可能丢失两次持久化之间的数据），AOF（日志形式记录每一次的写入和删除操作，运行效率低，恢复时间长）
过期删除策略：惰性（访问时检查是否过期）+定期（定期检查是否过期）
内存不足淘汰策略：最久没用，一段时间最少使用，快过期的
高可用集群方案：主从、哨兵、分片
主从同步原理：全量同步+增量同步
第一次同步生成RDB给slave，发送期间产生缓存区间，后续slave持续读取缓存区间中的数据
缓存一致性：延迟双删，canal
RabbitMQ：
producer、（vhost）broker（exchange、quene），consumer
消息可靠：
1.不被重复消费（幂等性：执行多次与执行一次影响相同）
2.消息不丢失
发送方（异步确认和重发），MQ（将消息持久化），接收方（异步确认机制）
# **分布式事务（Distributed Transactions）：**
**概念：** 分布式事务是一种涉及多个独立的、自治的事务管理器的事务。在分布式系统中，跨越多个节点的操作需要保证一致性和可靠性。
**解决方案：**
1. **两阶段提交（Two-Phase Commit，2PC）：**
    - 阶段1：协调者询问各参与者是否可以提交。
    - 阶段2：如果所有参与者同意，则协调者发出提交命令；否则，发出回滚命令。
    - 缺点：单点故障问题，阻塞时间可能较长。
2. **补偿事务（Compensating Transactions）：**
    - 引入补偿操作，事务出现问题时执行补偿，而非回滚。
    - 缺点：需要设计可逆的操作，实现相对复杂。
3. **分布式消息队列：**
    - 使用消息队列作为分布式事务的解决方案，确保消息的可靠传递。
    - 常用工具：RabbitMQ、Apache Kafka。
# **分布式一致性（Distributed Consistency）：**
**概念：** 分布式一致性是指在分布式系统中，不同节点上的副本保持一致的状态，确保数据的正确性。
**解决方案：**
1. **Paxos算法：**
    - 通过选举机制保证一致性，适用于多节点环境。
    - 缺点：理解和实现相对较难。
2. **Raft算法：**
    - 简化了Paxos，更易理解和实现。
    - 提供选主过程，确保数据一致性。
3. **CAP理论：**
    - 指出在分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition Tolerance）三者不可同时满足。
    - 根据具体需求进行权衡。
# **分布式锁（Distributed Lock）：**
**概念：** 分布式锁是一种用于协调分布式系统中多个节点对共享资源的访问的机制。
**解决方案：**
1. **ZooKeeper：**
    - 基于ZooKeeper实现分布式锁，通过创建临时有序节点实现。
    - 优点：可靠，有序性好。
2. **Redis分布式锁：**
    - 利用Redis的SETNX（set if not exists）指令，实现互斥。
    - 需要考虑过期时间，防止死锁。
3. **基于数据库的分布式锁：**
    - 利用数据库的事务和唯一约束，确保锁的唯一性。
    - 缺点：性能相对较差，依赖数据库的可靠性。
Linux：
1. **`ls` - 列出文件和目录：**
    - 用法：`ls [选项] [文件或目录]`
    - 示例：`ls -l` 列出详细信息，`ls -a` 显示隐藏文件。
2. **`cd` - 切换目录：**
    - 用法：`cd [目录]`
    - 示例：`cd /home/user` 进入用户目录。
3. **`pwd` - 显示当前工作目录：**
    - 用法：`pwd`
    - 示例：显示当前所在的绝对路径。
4. **`cp` - 复制文件或目录：**
    - 用法：`cp [选项] 源目录 目标目录`
    - 示例：`cp file1.txt /path/to/destination`
5. **`mv` - 移动文件或目录：**
    - 用法：`mv [选项] 源目录 目标目录`
    - 示例：`mv file1.txt /path/to/destination`
6. **`rm` - 删除文件或目录：**
    - 用法：`rm [选项] 文件或目录`
    - 示例：`rm file1.txt` 删除文件。
7. **`mkdir` - 创建目录：**
    - 用法：`mkdir [选项] 目录名`
    - 示例：`mkdir new_directory` 创建一个新目录。
8. **`rmdir` - 删除空目录：**
    - 用法：`rmdir [选项] 目录名`
    - 示例：`rmdir empty_directory` 删除一个空目录。
9. **`cat` - 查看文件内容：**
    - 用法：`cat [文件]`
    - 示例：`cat file.txt` 显示文件内容。
10. **`grep` - 在文件中查找文本：**
- 用法：`grep [选项] 搜索词 文件`
- 示例：`grep "pattern" file.txt` 在文件中搜索指定模式。
**SpringCache：**
![[Pasted image 20231218151639.png]]**Nacos，openfeign，gateway**
nacos：
1. **安装和启动：**
    - 下载并启动Nacos服务器。
    - 在浏览器中访问Nacos控制台（默认地址：[http://localhost:8848/nacos）。](http://localhost:8848/nacos%EF%BC%89%E3%80%82)
2. **服务注册：**
    - 登录Nacos控制台，选择“服务管理”。
    - 点击“新增服务”，填写服务名、IP、端口等信息。
3. **服务发现：**
    - 在消费者项目中引入Nacos客户端依赖。
    - 在代码中使用Nacos提供的API进行服务发现。
openfeign：
2. **启用Feign：**
    - 在启动类上添加 `@EnableFeignClients` 注解。
3. **创建Feign接口：**
    - 创建一个接口，使用 `@FeignClient` 注解指定服务名。
**使用Feign：**
- 在代码中注入Feign接口并使用。
gateway：
在 `application.yml` 文件中配置路由信息。
3. **启用Gateway：**
    - 在启动类上添加 `@EnableGateway` 注解。
4. **访问服务：**  
    - 通过Gateway访问服务。