**垃圾回收器**
分为串行、并行、并发、G1
**CMS**：初始标记阶段，并发标记阶段，重新标记阶段，并发清除
其中第一、三阶段需要STW
初始标记：标记所有直接被GCroot关联的对象，速度比较快
并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程，耗时较长，但是是并发执行，不需要暂停用户线程
重新标记：修正并发标记期间,因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要STW，但时间不会太长
并发清除：清理删除掉标记阶段判定的已经死亡的对象,释放内存空间，不需要移动存活对象,可以与用户线程同时并发（产生内存碎片）
由于最耗费时间的并发标记与并发清除阶段都是不需要暂停用户线程的,所以整体的回收是低停顿的
**G1**：并行回收器,它把堆内存分割为很多不相关的区域(Region)(物理上不连续)，所有region均可以用来当作eden，survivor，old，humongous（存储大对象）（**区域化内存布局**）
Region之间是复制算法,但整体上实际可看作是标记-整理算法
G1除了追求低停顿外,还能建立可预测的停顿时间模型,能让使用者明确指定在一个长度为M毫秒的时间片段内,消耗在垃圾收集上的时间不得超过N毫秒（**可预测停顿时间**），因为会优先回收价值高的region（**垃圾优先**）
可以只选取部分区域进行内存回收,这样缩小了范围,因此对于全局停顿情况的发生也能得到较好的控制，可以进行**混合回收**，同时处理新生代和老年代
**并行和并发**执行垃圾回收操作，并行加快标记和复制的速度，并发减少垃圾回收对应用程序的停顿时间
回收步骤与CMS相似，第三步骤的名称改为最终标记（初始标记，并发标记，最终标记，筛选回收）

**JUC常见工具类**（关于锁的补充）
1.juc核心**AQS**：AbstractQueuedSynchronizer和synchronized的monitor类似，实现了一套管程控制框架，用volatile int的state作为锁对象并记录重入次数，CAS修改state来上锁/释放，同样实现了entryList和waitSet供线程阻塞等待。
2.**ReentrantLock**：在AQS基础上完成的和synchronzied类似的锁，优点在于可尝试tryLock、可超时、可打断、可设置为公平锁、可通过Condition灵活添加waitSet。性能上由于synchronized加入锁升级和自旋优化后差别不大。
3.**ReentrantReadWriteLock**：读写锁，读-读不互斥，提高资源共享效率。state高16位记录读锁，低16位记录写锁，阻塞队列中读线程被唤醒时递归唤醒后继读线程。
4.**Semaphore**：信号量，限制并行访问共享资源的线程的个数，类似于抢车位。可用于单机限流，acquire申请资源访问权限，realese释放，state为最大并行线程数。
5.**CountDownLatch**：用于线程间同步协作，一个线程await等待其它线程完成任务时countDown，state为count数。
6.**CyclicBarrier**：循环栅栏，构造参数int parties、 Runnable barrierAction。state为parties，子任务线程await等待时state-1，state为0时调用barrierAction的run方法；可循环使用。
7.线程池也在JUC里

ReentrantLock有一个内部类Sync继承了AQS，AQS作为一个构建同步锁的框架，维护了阻塞队列和锁状态state，同时ReentrantLock实现了Lock，可以作为锁使用
这样理解：lock是一个锁的用途，比如lock（）和unlock（）上锁和放锁，是一种抽象的概念锁，而AQS是一个构建锁的框架，通过这个框架中的一些构造才能真正制造出一把能用的锁

Condition是一个接口，AQS内部实现了它（ConditionObject），并提供了一个获取ConditionObject实例的方法，ReentrantLock继承了AQS，内部有一个sync类通过AQS提供的方法获取ConditionObject实例，每个 ReentrantLock对象都可以有多个关联的Condition，这样可以在同一个锁上实现多个等待队列，每个队列用于不同的条件，可以实现特定条件下的线程唤醒
Condition 的 await 和 signal 与 Object 的 wait 和 notify 有什么区别
1. **关联对象**：
    - `Condition` 是与 `ReentrantLock` 相关联的，通过 `ReentrantLock.newCondition()` 创建。一个 `ReentrantLock` 可以有多个与之相关联的 `Condition`，每个用于不同的等待和通知。
    - `Object` 的 `wait` 和 `notify` 是与每个对象关联的，任何对象都可以调用它们。
2. **等待和通知的粒度**：
    - `Condition` 允许精确地选择哪些线程被唤醒，因为一个 `ReentrantLock` 可以有多个 `Condition`。使用 `await` 和 `signal` 可以指定具体的 `Condition`。
    - `Object` 的 `wait` 和 `notify` 是全局的，当调用 `notify` 时，所有在该对象上等待的线程都有可能被唤醒。
3. **可中断性**：
    - `Condition` 的 `await` 方法支持线程等待期间的中断，即线程在等待时可以响应中断。
    - `Object` 的 `wait` 方法在等待时无法响应中断，只能等待被通知或超时。
4. **等待队列管理**：
    - `Condition` 提供了更多的等待队列管理方法，如 `awaitNanos`、`awaitUntil` 等，以及支持等待队列中指定条件的线程。
    - `Object` 的 `wait` 方法较为简单，只支持基本的等待和唤醒。

**六大排序算法**
1. **冒泡排序（Bubble Sort）：**
    - 每一轮都从前往后依次比较相邻的两个元素，如果逆序则交换。经过一轮的比较，最大的元素会沉到数组末尾。时间复杂度为 O(n^2)。
2. **选择排序（Selection Sort）：**
    - 每一轮找到未排序部分的最小元素，与未排序部分的第一个元素交换。经过一轮的比较，当前最小的元素会被放在当前已排序部分的末尾。时间复杂度为 O(n^2)。
3. **插入排序（Insertion Sort）：**
    - 将数组分为已排序和未排序两部分，每次从未排序部分取一个元素插入到已排序部分的合适位置。时间复杂度为 O(n^2)，但对于小规模数据或近乎有序的数据表现较好。
    - 希尔排序（Shell Sort）是一种改进版的插入排序算法。它的基本思想是将原始数组分割成若干个子数组，然后分别对这些子数组进行插入排序。这种分割和排序的过程会逐渐减小子数组的长度，最终完成整个数组的排序
4. **快速排序（Quick Sort）：**
    - 通过选择一个基准元素，将数组分为两部分，左边的元素小于基准，右边的元素大于基准。对左右两部分分别递归地进行快速排序。平均时间复杂度为 O(N\*log2N)。
5. **归并排序（Merge Sort）：**
    - 将数组分为两半，对每一半递归地进行归并排序，然后将两个有序的子数组合并为一个有序数组。时间复杂度为 O(N\*log2N)。
6. **堆排序（Heap Sort）：**
    - 将待排序的元素构建成一个最大堆，然后逐步将堆顶元素与末尾元素交换，并重新调整堆，直到整个数组有序。时间复杂度为 O(n log n)。
    - 建堆的时间复杂度为O(N);  向下调整算法的时间复杂度为O(log2N);  堆排序的总体时间复杂度为O(N\*log2N);
总体而言，冒泡排序、选择排序、插入排序、堆排序和希尔排序都是原地排序算法，它们在排序过程中不需要额外的辅助空间，因此空间复杂度为 O(1)。而归并排序需要额外的空间来存储中间结果，因此空间复杂度为 O(n)，快速排序递归需要空间，最好O(logn)，最坏O(n)

**多路复用**
多路复用（Multiplexing）是一种在计算机网络和操作系统中常用的技术，它允许多个输入或输出流通过同一个通道进行传输。这样可以提高资源的利用率，减少系统的开销。多路复用常见的应用场景包括网络编程和输入输出操作。
多路复用的主要特点：
1. **单一通道传输多个流：** 多路复用通过一条通道同时传输多个流，可以是输入流或输出流。这样可以避免为每个流创建独立的通道，提高资源利用率。
2. **非阻塞IO：** 多路复用可以实现非阻塞的IO操作，一个通道上的某个流没有数据可读或可写时，可以切换到其他流进行操作，而不需要等待。
3. **提高系统性能：** 通过充分利用系统资源，多路复用可以提高系统的性能，减少资源的浪费。
常见的多路复用技术：
1. **Select：** 是一种基于轮询的多路复用技术。在操作系统层面，程序通过 `select` 调用向内核注册感兴趣的事件，内核通过轮询判断事件是否就绪。常见于 Unix/Linux 等系统。
2. **Poll：** 与 Select 类似，但采用了更灵活的数据结构，可以处理更大数量的文件描述符。同样是基于轮询的方式。
3. **Epoll：** 是 Linux 下的一种高性能多路复用机制，与 Select 和 Poll 相比，Epoll 支持更大的并发连接数，并且不随着文件描述符数量的增加而降低性能。使用事件通知的方式，只返回活跃的文件描述符，避免了遍历整个文件描述符集合。没有文件描述符数量的限制，适用于高并发场景