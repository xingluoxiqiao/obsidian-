# 数组，哈希表，链表
常用双指针，滑动窗口，优先级队列
字符串：看做特殊的数组
KMP算法，动态规划，贪心
栈和队列：元素的先后顺序有影响
# 二叉树
1.弄清楚遍历的顺序（中节点是需要处理的节点，看处理的过程应该在遍历完左右子树的哪个位置，比如要获取到左右子树的状态再处理，就可以用后序，还有标记法，在将来需要处理的节点处标记一下，后续遇到标记了就可以进行处理）
2.栈，队列，优先级队列的使用
priorityQueue：offer，pool，peek，size
# 递归
递归不是对算法的优化，而是一种思维，大事化小，小事化了
简化思考的过程，同时时间复杂度又不太高（因为递归占用了空间）
递归函数的思考过程：
1.确定递归函数的参数和返回值，以及明确每次递归要做的事（返回值是什么）
2.确定递归的出口（小事化了），除了函数的出口外，每次递归的逻辑都是一样的
3.确定单层逻辑，取除出口外的任意一个节点分析，完善其处理逻辑，如果用到了与递归函数相同的逻辑，直接使用即可（大事化小），不要过多思考（确定好参数的改变即可）
# 回溯
通常与递归结合使用，用于寻找所有可能，本质上是一种暴力算法，通常是出现超多层循环时考虑使用
每种回溯可以抽象为树状结构，树宽是每次递归可以选取的元素数目（for循环），树高是递归层数
因此，如果每次递归时元素的数目改变了（比如不能重复），要从for循环的i的范围考虑
如果递归可以减少层数，可以从终止条件处入手
回溯的状态可以通过参数表现，也可以手动回溯，前者比较简洁，后者比较清晰
回溯中如果要对结果去重可以采取多种方式，推荐使用set
# 动态规划
也可以看作是一种大事化小的思维，但需要每次的状态之间有一定的联系，这种联系通过状态转移方程显示，一般的步骤是：
1.定义dp数组以及确定dp数组的含义（一般题目问什么，就把dp数组定义成什么，最后直接返回数组的最后一个值即可）
2.确定状态转移方程
3.确定dp数组的初始化，一般是根据题意或者常识
4.确定数组的遍历顺序，一般都是正序，但是需要简化空间复杂度时，会将二维简化为一维，二维数组的每个数都是从其左上角的数得来的，如果正序遍历，左侧的数被覆盖了，导致无法正确计算，而倒序遍历就能避免这种情况
5.如果允许，可以打印dp数组验证
# 贪心
没有什么技巧，但是可能会综合哈希表，队列，滑动窗口等