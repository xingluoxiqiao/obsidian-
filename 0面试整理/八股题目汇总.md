# 计网
**OSI七层模型，TCP/IP模型，每层是干嘛的，有什么常见的协议**
应用,表示,会话,传输,网络,数据链路,物理
应用,传输,网络,网际接口
应用:http,smtp,pop3
传输:tcp,udp
网络:ip,icmp,arp,nat
**http的特点**
无状态,明文传输
**http为什么是无状态的，有什么好处**
http的报文不会保存用户的信息,减轻服务器的负担,更好处理并发
**可以用什么保持状态**
**cookie和session有什么区别**
cookie保存的数据较少,保存在浏览器,可以随报文在客户端和服务器端传递,持续时间较长
session可以基于保存在cookie中的sessionID获取用户信息,保存在服务器端,可以保存大量数据,但持续时间较短
**子网掩码的作用**
子网掩码是用于划分网络地址和主机地址的一个32位二进制数。
它与IP地址结合使用，用于确定一个IP地址中哪些位表示网络地址，哪些位表示主机地址。
子网掩码的作用主要有两个方面：
- 确定网络地址：子网掩码通过将IP地址中的网络部分与主机部分进行分隔，将网络地址和主机地址进行划分。子网掩码中的1表示网络部分，0表示主机部分。通过与IP地址进行逻辑与运算，可以得到网络地址。
- 确定主机地址范围：子网掩码中的0表示主机部分，确定了主机地址的范围。主机地址范围是指在同一个网络中可以分配给主机的不同IP地址。子网掩码中主机部分的位数决定了主机地址的数量，可以根据主机地址范围来分配IP地址给不同的主机。保留两个地址：网络地址（表示整个子网）和广播地址
子网掩码的正确配置对于网络通信的正常运行非常重要。它可以帮助路由器和交换机等网络设备正确地识别网络地址和主机地址，实现数据的正确传输和路由。
**https和http有什么区别**
https端口443,http80
https在http基础上采用了ssl/tls加密,数据在网络中不再明文传递,更加安全
https由于加密需要申请证书，并且消耗更多cpu和内存资源
**http的常见状态码**
1xx中间状态
2xx成功:200OK一切顺利,204NoContent处理成功但不返回任何数据
3xx:301Moved Permanently 永久重定向,302found临时重定向
4xx:客户端错误400badRequest:http请求有问题,401unauthorized未认证,403forbiden请求被禁止,404notFound请求的资源没找到
5xx:服务器状态异常:500internetServerError服务器出问题bug,502badGateway服务器返回错误响应
**http1.0短连接，http1.1长连接**
短连接:每次发送请求都进行一次TCP连接
长连接:一次TCP连接可以处理多次请求
流水线:不用等到服务器返回响应就可以继续发送下一次请求,有可能造成队头阻塞
**https的加密方式**
**对称加密和非对称加密**
在进行身份验证时进行非对称加密,后续数据传输进行对称加密
对称加密:加密方和解密方使用同一密钥,互相加解密
非对称加密:分为公钥和私钥,公钥可以随意发放,私钥自己留用，公钥可以解密私钥加密的数据,私钥可以解密公钥加密的数据
**https怎么保证对方可信**
服务器需要向CA机构获取认证证书,证书上有用机构的私钥加密的电子签名
认证阶段向对方发送认证证书,对方通过电子签名的公钥解析电子签名,确保对方被认证过
**http的常见请求方法**
GET:请求指定的资源
POST:向指定资源提交数据，进行处理
DELETE:请求服务器删除指定的资源
PUT:向指定资源位置上传最新内容
**GET和POST的区别**
GET用于获取资源,POST用于修改资源
GET请求参数位于url路径,明文显示,长度有限制,只支持askii编码
POST请求参数位于请求体,相对安全,理论上没有长度限制,支持多种编码形式(字段定义)
**GET请求为什么参数需要编码**
参数用的是key=value的形式,如果不编码,要是key或者value里面有类似=这样会引起歧义的字符,会无法解析或解析错误
**从输入网址到获得页面的过程**
浏览器解析url,通过dns解析获取ip
浏览器与服务器建立tcp
浏览器构建并发送http请求
服务器接收请求并处理
服务器返回响应
客户端解析获取相应的资源,解析并渲染获取页面
关闭tcp连接
**DNS协议，过程**
dns是基于udp,将域名解析获取对应服务器的ip的一种协议
通过dns服务器进行,分为根,顶级,权威,本地
dns解析式,依次查询浏览器缓存,本地dns服务器,如果找不到,
可以采用迭代或递归的方式访问根
迭代就是指路,依次访问根,顶级,权威返回给本地
递归就是根去访问顶级,权威,再逐级向上返回最后回到根再返回给本地
本地缓存后返回给浏览器ip
**IP地址和MAC地址**
IP地址是逻辑地址,是可以变化的;MAC地址是网卡制造商制造时赋予的全球唯一标记
IP地址32位,MAC地址48位(前24位由IEEE管理,后24位由网卡制造商分配保证不会重复)
**ARP**
地址解析协议:ARP 表、广播问询、单播响应
查询分组和响应分组,包含发送和接收的 IP 地址、发送和接收的 MAC 地址
(发送查询分组不知道对方的MAC地址,采用广播地址)
每台网络设备维护一个ARP表,A需要获取某台网络设备B的MAC地址时
先解析ip地址判断其是否与自己处在同一局域网下,如果是则直接采用广播地址向局域网中每一台设备发送查询分组,B收到该分组后会构造ARP响应分组定向发送给A,并在自己的ARP表中增加一条记录<ip,mac,ttl>(ttl一般是20分钟)
A收到后可以进行解析获取B的MAC地址,向自己的ARP表中增加一条记录
如果不在同一局域网下,则要先获取当前局域网中对方局域网的本子网接口路由器
通过该路由器中转一下,基本流程同上(路由器也是网络设备,有MAC)
**TCP，UDP区别**
TCP面向连接,保证可靠性,面向字节流,头部20字节，只支持一对一连接，有拥塞控制
UDP面向无连接，不保证可靠性，面向报文，头部8字节，支持各种连接
**TCP怎么保证可靠性**
数据包校验，失序数据包重排序，丢弃重复数据，应答机制，超时重发，流量控制
**TCP拥塞控制**
防止过多的数据注入网络，使网络中的路由器或链路过载
慢启动，拥塞避免，快重传，快恢复
从1开始指数增长，加法增大，收到三个重复确认时立即进行重传，并将拥塞窗口减小一半
**TCP流量控制**
发送方和接收方各自维护一个流量窗口，接收方的窗口大小取决于应用，系统，硬件的控制，发送方的窗口大小则取决于接收窗口。接收方可以通过发送含有window字段的确认报文来控制发送窗口的大小，影响发送的速率，防止发送和接收的速度不匹配导致数据丢失
**三次握手，四次挥手**
三次握手：
1.客户端发起连接请求生成随机起始序列号seq，标志位SYN=1，CLOSE--->SYN_SENT
2.服务端生成确认号ack=seq+1，随机起始序列号seq，标志位SYN=1,ACK=1,LISTEN--->SYN_RCVD
3.客户端收到响应，返回ACK=1，seq=ack，ack=seq+1，双方都进入ESTABLISHED
四次挥手：
1.A向B发送连接释放报文（FIN=1,seq），停止发送数据，进入FIN_WAIT_1
2.B收到后发送确认报文（ACK=1,ack,seq），进入CLOSED_WAIT，A--->B连接释放
3.A收到B的确认报文，进入FIN_WAIT_2
4.B发送完数据，发送连接释放报文（FIN=1,ACK=1,seq，ack），进入LAST_ACK
5.A发送确认报文（ACK=1,seq，ack），进入TIME_WAIT，等待2MSL后关闭进入CLOSED
B收到确认报文后关闭，否则重传连接释放报文段
**为什么要等2MSL，MSL具体是多少**
保证A发送的最后一个ACK报文段一定能被B接收到
防止已失效的连接请求报文段重新出现在新的连接中（使本次请求产生的所有数据都消失在网络中）
**为什么不是两次握手**
防止已失效的连接请求报文段重新被接收到，导致服务器端一直处于连接无法关闭状态
**IP地址分类**
ABCDE:五类
0，10，110，1110，11110
**DDoS 攻击（分布式拒绝服务攻击）**
DDoS 攻击旨在通过超载系统、服务或网络资源的流量，使其无法正常提供服务。攻击者使用多台计算机或设备协同工作，发送大量请求，导致目标系统过载，服务不可用。
**CSRF 攻击（跨站请求伪造攻击）**
CSRF 攻击利用用户在已通过身份验证的网站中的活动权限，以其名义执行非预期的动作。攻击者通过伪装成合法用户发送请求，执行未经用户许可的操作，利用用户在目标网站中的有效身份验证状态。防御方法包括使用 Anti-CSRF Token、检查 Referer 头和 SameSite Cookie 属性。
# OS
**进程和线程**
进程是程序的一次执行，一个进程可以包含多个线程
进程有独立的内存空间，线程共享进程的内存空间
线程是更轻量的进程，创建，销毁，上下文切换时的开销更小
进程间的通信比较复杂，线程间的通信可以直接通过共享内存
**进程间的通信方式**
（匿名）管道：用于父子或兄弟进程间
有名管道：以磁盘文件形式存在，可以是任意两个进程间，遵循先进先出
消息队列：克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点，存放在内核中，内核重启或显式删除时才会被删除，可以实现随机顺序
信号：通知接收进程某个事件已经发生
信号量：信号量是一个计数器，用于多进程对共享数据的访问，意图在于进程间同步
套接字：主要用于在客户端和服务器之间通过网络进行通信
共享内存：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新，依靠某种同步操作，如互斥锁和信号量等
**用户态和内核态，怎么切换**
可以通过系统调用，中断和异常
系统调用是主动的切换，用户程序可以通过调用系统调用接口，使处理器产生中断或异常，处理器会暂停用户程序的执行，进入内核态处理用户程序的请求，随后返回用户态
**并行和并发**
并行是多个程序在多个处理器上同时运行
并发是一个处理器快速交替执行多个程序
**同步和异步**
同步：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待
异步：调用在发出之后，不用等待返回结果，该调用直接返回
**进程的状态，线程的状态（java）**
进程的状态：新建，就绪，运行，阻塞，终止
线程的状态：新建，运行，阻塞，等待，限时等待，终止
**僵尸进程，孤儿进程**
僵尸进程是指一个进程的子进程终止后，不会被立即清除，还会保留一些基本信息，目的是为了让其父进程查询退出状态，获取到后就会被清除，否则可能一直存在
孤儿进程是指一个进程的父进程先于它退出，它会被init进程接管，继续在系统中运行
**进程调度算法**
先来先服务,最短作业优先,最短剩余时间优先,优先级调度,时间片轮转，多级反馈队列
**上下文切换**
是指多线程环境下，一个线程切换到另一个线程时，保存当前线程的上下文，加载另一个线程的上下文
**线程间的同步机制**
**互斥锁(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 `synchronized` 关键词和各种 `Lock` 都是这种机制。
**读写锁**:允许多个线程同时读取共享资源，但只有一个线程可以对共享资源进行写操作。
**信号量(Semaphore)**：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。
**屏障（Barrier）**：屏障是一种同步原语，用于等待多个线程到达某个点再一起继续执行。当一个线程到达屏障时，它会停止执行并等待其他线程到达屏障，直到所有线程都到达屏障后，它们才会一起继续执行。比如 Java 中的 `CyclicBarrier` 是这种机制。
**事件(Event)** :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。
**虚拟内存**（Virtual Memory）：
虚拟内存是计算机系统中的一种技术，它允许程序访问一个比实际物理内存更大的地址空间。在虚拟内存的概念中，每个程序都有自己的虚拟地址空间，而不受物理内存的限制。虚拟内存的主要目标是提供更大的地址空间以及更灵活的内存管理。
1. **虚拟地址空间：** 每个程序都有自己的虚拟地址空间，通常是一个连续的地址范围。这个范围比实际的物理内存大。
2. **分页机制：** 虚拟内存通过分页机制将程序的虚拟地址空间分成固定大小的块，称为页。物理内存也被分成相同大小的页框。
3. **页面置换：** 当程序访问的数据不在物理内存中时，会触发页面置换机制，将需要的页面从磁盘加载到内存，覆盖原来的内容。
4. **内存保护：** 虚拟内存还允许操作系统对内存进行保护，防止程序越界访问或修改其他程序的内存。
**内存分段**（Memory Segmentation）：
内存分段是一种将物理内存划分为不同的段的技术。每个段可以包含程序的一部分，如代码段、数据段、堆段、栈段等。每个段有自己的基址和界限，这样就可以实现不同段之间的隔离和保护。
1. **段的划分：** 物理内存被划分为不同的段，每个段负责存储特定类型的数据。
2. **基址和界限：** 每个段都有一个基址和一个界限，基址指定了段在物理内存中的起始位置，界限指定了段的大小。
3. **隔离和保护：** 不同的段之间是相互隔离的，每个段都有自己的访问权限，实现了对不同数据的保护。
**内存分页和多级页表**
内存分页是将物理内存和虚拟内存都划分成固定大小的页面的技术。这样，程序的虚拟地址空间和物理地址空间都被划分成相同大小的页。分页机制通过将程序的虚拟地址空间映射到物理地址空间的页面上，实现了灵活的内存管理。
多级页表是一种优化页表结构的方式，用于管理虚拟地址空间和物理地址空间之间的映射关系。由于一个大型进程的页表可能非常庞大，占用大量内存，多级页表通过将页表分成多个层次，仅在需要时加载部分页表，从而节省内存。
主要思想是将一个大的页表划分成多个小的页表，形成一个多级的结构。例如，一个三级页表可以分为页目录表、页中间表和页表三个级别。
1. **虚拟地址到物理地址的映射：** 多级页表通过多级的查找过程将虚拟地址映射到物理地址。
2. **节省内存：** 只有在需要时加载部分页表，有效节省内存空间。
3. **快速访问：** 多级页表能够通过更快的局部性原理来提高访问效率。


# 数据结构
**大根堆，小根堆（左旋、右旋），优先级队列**
**二叉树，二叉搜索树，二叉平衡搜索树，B树，B+树，跳表**
# java基础
**Java 的基本数据类型和他们分别占用的位数**                                                                    
byte8 short16 int32 long64 double32 float64 char16 boolean不确定（1位，1字节，4字节）
**编程六大原则**（SOLID）
**单一职责原则**:即一个类应该只有一个职责。
**开放/封闭原则**:软件实体（类、模块、函数等）应该**对扩展开放，对修改关闭**。
**里氏替换原则**:子类必须能够替换掉父类而不影响程序的正确性。
**接口隔离原则**:一个类只应该实现它需要的接口。
**依赖倒置原则**:高层模块不应该依赖于低层模块，二者都应该依赖于抽象。
**合成/聚合原则**:聚合关系应该用于表示整体与部分的关系，而不是用于表示对象的包含关系。
**面向对象特征、优点**
封装：把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息，保护内在构造，不被随意更改，使用简单
继承：使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。
多态：表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。
易维护、易复用、易扩展
**接口，实现类**
**共同点**：
都不能被实例化。
都可以包含抽象方法。
都可以有默认实现的方法（Java 8 可以用 `default` 关键字在接口中定义默认方法）。
**区别**：
接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。
一个类只能继承一个类，但是可以实现多个接口。
接口中的成员变量只能是 `public static final` 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。
**包装和拆箱，int缓存**
**装箱**：将基本类型用它们对应的引用类型包装起来；
**拆箱**：将包装类型转换为基本数据类型；
java会自动对基本数据类型提供装箱和拆箱，例如
`int i=10等价于Integer i=Integer.valueof(10)`
`Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 \[-128，127]的相应类型的缓存数据，`Character` 创建了数值在 \[0,127]范围的缓存数据，`Boolean` 直接返回 `True` or `False`，缓存范围内的值进行自动拆装箱时返回的都是同一个对象，而通过构造方法构造的方法则不是，valueof方法才可能会返回缓存中的对象
**重载和重写**
重载发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。
重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。方法名相同，参数列表相同，内部实现不同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类
**深拷贝，浅拷贝，引用拷贝**
浅拷贝是指复制对象时，只复制对象本身及其所有基本属性的值，而不会复制对象包含的引用类型的属性所引用的对象。这意味着原始对象和浅拷贝后的对象仍然共享相同的引用类型的属性。
深拷贝是指复制对象时，不仅复制对象本身及其所有基本属性的值，还会递归复制对象包含的引用类型的属性所引用的对象。这样，原始对象和深拷贝后的对象完全独立，不共享引用类型的属性。
引用拷贝是指复制对象时，只复制对象的引用而不复制对象本身。这意味着原始对象和引用拷贝后的对象实际上是相同的对象，对其中一个对象的修改会影响到另一个对象。
也就是两个不同的引用指向同一个对象、
**object类的方法（equals，hashcode，finalize，wait，notify，clone，tostring）**
hoshcode和equals都是用来判断两个对象是否相等的方法，hashcode一般情况下很快，但是可能出现hash碰撞导致不够准确，而equals很准确并且可以被重写按照自定义方式判断两个对象是否相等
finalize是对象被垃圾回收前被调用
**\==和equals的区别**
`==` 比较的是对象的引用（基本类型比较值，引用类型比较引用），而 `equals()` 方法比较的是对象的内容。在实际应用中，特别是对于自定义类，需要根据具体需求选择适当的方式来进行对象比较
**string为什么不可变**
保存字符串的数组被 `final` 修饰且为私有的，并且`String` 类没有提供/暴露修改这个字符串的方法。
String类被 `final` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变。
**字符串常量池**
是java专门为存储字符串常量开辟的一块空间，1.7前在永久代，1.7后转移到堆中
**反射**
获取类中的各种信息加以利用
获取类class对象（具体类.class、class.forname()、对象实例.getClass()、classLoader.loadClass(全类名)）通过getDeclaredxxx方法获取各种信息
**静态代理与动态代理**
静态代理实现步骤:（每个被代理类都需要创建响应的代理类，非常不灵活）
1. 定义一个接口及其实现类；
2. 创建一个代理类同样实现这个接口
3. 将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。
动态代理：
JDK动态代理：InvacationHandler自定义处理逻辑（invoke方法中调用原方法）
`invoke()` 方法有下面三个参数：
1. **proxy** :动态生成的代理类（传入被代理类实例）
2. **method** : 与代理类对象调用的方法相对应
3. **args** : 当前 method 方法的参数
创建动态代理工厂类（返回代理对象），通过Proxy.newProxyInstance(目标类的类加载器,代理需要实现的接口,自定义 InvocationHandler)方法返回代理对象，从而代理实现原方法（可以新增内容）
CGlib动态代理（引入依赖）：需要自定义 `MethodInterceptor` 并重写 `intercept` 方法，`intercept` 用于拦截增强被代理类的方法，随后创建代理对象工厂使用enhance对象设置
底层是通过修改被代理类的字节码生成子类并覆盖其方法实现的
springAOP是基于动态代理实现的，当被代理类有实现的接口时，采用jdk，否则cglib
一般来说jdk的性能会好一些

# 集合
**collection，map**
**list，set，queue，map**
**arraylist，linkedlist，hashset，treeset，priorityqueue，stack，hashmap，treemap**
**arraylist的扩容**
懒加载，默认初始化数组长度10，放满时扩容为1.5倍,复制法
**hashmap**
初始化、数组长度、扩容机制、哈希冲突解决
不通过构造函数传入初始容量时，数组大小默认是16（懒加载），可以通过参数构造比16小的数组
通过构造函数传入初始容量时，会选取大于参数的最近的2的次幂数
当放入元素时检查到加入该元素后会超过负载因子（默认0.75）时（而不是放入该元素前就超过），会进行扩容，数组长度变为原来的两倍，同时原先的元素进行基于新数组长度重新hash确认新位置
**哈希冲突解决**
1. **拉链法（链表法）：**
    - 当发生哈希冲突时，相同哈希码的键值对会被存储在同一个位置的链表中。
    - 在Java 8之前，`HashMap` 使用的是链表来解决冲突。
    - Java 8及之后，当链表长度超过一定阈值（8）时，链表会转化为红黑树，以提高查找效率。
2. **开放地址法：**
    - 通过线性探测、二次探测等方式，在发生冲突时，寻找下一个可用的位置。
    - 不同于拉链法，开放地址法将所有的元素存储在数组中，没有额外的链表结构。
**hashmap的大小为什么要是2的次幂**
用位运算代替取模运算，简化hashcode到位置索引的映射运算
当数组大小为2的次幂时，与运算可以确保哈希码的每一位都对数组的索引产生影响，从而增加了键在数组中的分布均匀性
**关于concurrenthashmap**
是hashmap在多线程下的替代方案
 **分段锁设计：** `ConcurrentHashMap` 使用了分段锁（Segment），默认分成16个段。每个段相当于一个小的 `HashMap`，在读操作时只锁住对应的段，而不是整个表。**允许多个线程同时执行读操作**，不会阻塞其他读操作。这提高了读操作的并发性，使得在读多写少的场景中性能表现较好。 在**写操作时，只有涉及到的段被锁住**，其他段的读写操作可以并发进行。这意味着在写入操作上也有一定的并发性，相较于传统的同步 `HashMap`，性能有所提高。
在 JDK 7 中，`ConcurrentHashMap` 使用了分段锁的设计，每个段都有一个独立的锁，这样在大多数情况下，不同段的读操作可以并发执行。在 JDK 8 中，`ConcurrentHashMap` 采用了一种**基于节点**（node）的锁设计，而不是对整个段进行加锁。这种设计在减小锁的粒度上更为灵活，允许更多的并发性。每个节点上都有一个独立的锁，当多个线程在同一段进行读写操作时，它们可以独立地操作不同的节点，提高了并发度。
# 多线程，并发编程
**保证并发的三大特征**
原子性，可见性，有序性
**volatile**
通过插入内存屏障（底层硬件指令）禁止指令重排序保证有序性
对变量的操作立即写入主存保证对其它线程立即可见
**乐观锁和悲观锁**
乐观锁的基本思想是假设在大多数情况下，冲突是不会发生的，因此在进行实际的数据修改操作之前，并不对数据加锁，而是在更新时检查在操作期间是否有其他对同一数据进行了修改。常用的实现方式是使用版本号或时间戳机制，通过比对版本号或时间戳来判断是否发生了冲突。
悲观锁的基本思想是在操作数据之前，先对数据进行加锁，确保在整个操作过程中数据不会被其他事务修改。悲观锁的典型实现是数据库中的行级锁或表级锁，通过数据库的锁机制来保证数据的一致性。
**共享锁和独占锁**
共享锁允许多个事务同时读取同一资源，但阻止它们同时写入该资源。多个事务可以同时持有共享锁，不会相互阻塞。
独占锁在事务对资源进行写操作时使用，它阻止其他事务同时读取或写入该资源。一旦一个事务持有了独占锁，其他事务就无法同时获取共享锁或独占锁。
**读锁和写锁**
读锁是共享锁的一种，它允许多个事务同时读取同一资源，但不允许事务写入。读锁之间不互斥，多个事务可以同时持有读锁。
写锁是独占锁的一种，它阻止其他事务同时读取或写入同一资源。写锁之间是互斥的，只有一个事务能够持有写锁。
**synchornized优化**
单个线程长时间运行时采用偏向锁
多个线程交替执行，竞争不激烈时升级为轻量级锁
多个线程激烈竞争时升级为重量级锁
锁只能升级，不能降级
1. **偏向锁（Biased Locking）：** 当一个线程访问同步代码块时，偏向锁会尝试给对象加锁。如果对象的锁状态为无锁状态，那么当前线程会尝试获取偏向锁，并将对象头的Mark Word设置为指向当前线程。如果其他线程访问同步代码块，偏向锁会升级为轻量级锁。
2. **轻量级锁（Lightweight Locking）：** 如果有多个线程访问同步代码块，偏向锁就会升级为轻量级锁。轻量级锁使用CAS操作来尝试获取锁，如果成功，对象头的Mark Word 指向当前线程。如果失败，表示有竞争，升级为重量级锁。
3. **重量级锁（Heavyweight Locking）：** 当多个线程竞争同步代码块的锁时，锁会升级为重量级锁。此时，每个线程都会在内部创建一个监视器（Monitor）对象，通过操作系统的互斥量来实现锁的互斥访问。
**synchornized底层原理，java对象头中有哪些信息**
底层原理是java对象头关联的minitor存储了当前持有锁的线程（owner，是唯一的）
还有阻塞队列和等待队列，获取锁时要先判断是否已经有其它线程在使用锁
	java对象头中有markword（hashcode，分代年龄，GC标记，锁的状态，获取到锁的线程ID）和对象所属类，如果是数组还有一个部分保存数组长度
**CAS**
CompareAndSwap，乐观锁，保证原子性，更新内存时判断内存是否被别人修改过，如果没有修改过就直接更新，否则重新获取值，直到更新完成
只能支持一个变量的原子操作，且频繁进行会导致CPU开销大
可能出现ABA问题，即判断（或突然阻塞）期间别人修改了值又改回来了，可以通过版本号或时间戳加以解决
**AQS**
AbstractQueuedSynchornizer抽象类，用于构造锁和同步类，内部有三个部分
state默认为0，通过CAS修改；FIFO阻塞队列（双向链表保证有些线程阻塞时中断了移除的快一点）；当前获取到锁的线程
可重入锁，先判断state，再判断当前持有锁的是不是自己，是state+1，每次释放-1
**reentrantlock**
AQS的一种实现，实现Lock，是可重入锁，提供多种机制可中断，可超时，可通过参数构造公平锁（默认false非公平）
**threadlocal**
内部维护一个成员变量ThreadLocalMap，可以实现线程资源隔离，每个线程可以保存自己的信息不互相影响，同时使线程内资源共享
**JMM**
java内存模型，是一个抽象概念，屏蔽硬件和OS的访问差异，实现java跨平台
所有变量都存在主存（线程间共享）中，每个线程要使用时从主存中复制到自己的工作内存，每个线程的工作内存相互隔离；由于复制有时延，且读写不是原子性，可能会有线程安全问题
**线程的创建**
继承Thread类，实现runnable，实现callable，从线程池创建
**线程池的参数，拒绝策略，处理任务的流程**
核心线程数，最大线程数，非核心线程存活时间，时间单位，阻塞队列，线程工厂，拒绝策略（抛异常（默认），返回给调用者执行，丢弃当前线程，丢弃最早线程）
先使用核心线程数，用完后进入阻塞队列，阻塞队列满后开非核心线程，非核心线程用完后开始使用拒绝策略
**线程池的分类，为什么不推荐直接使用内置线程池，有界队列和无界队列**
newfixed：可重用固定线程数的线程池
newCached：根据需要创建新线程的线程池
newScheduled：给定的延迟后运行任务或者定期执行任务
newSingle：只有一个线程的线程池
以上内置线程池的阻塞队列都是无界队列，Integer.MAX_VALUE不会放满，可能导致内存溢出，一般使用参数自定义线程池
**runnable和callable**
1. **返回值：**
    - `Runnable` 的 `run` 方法没有返回值。
    - `Callable` 的 `call` 方法有返回值，可以通过 `Future` 对象获取。
2. **异常处理：**
    - `Runnable` 的 `run` 方法不能抛出受检查异常，只能在方法内部进行处理。
    - `Callable` 的 `call` 方法可以抛出受检查异常，但需要通过 `Future` 对象的 `get` 方法捕获异常。
3. **线程池：**
    - `Runnable` 可以用于线程池中的任务。
    - `Callable` 也可以用于线程池，但需要结合 `ExecutorService` 和 `Future` 进行使用。
```java
// 提交 Callable 任务给线程池，得到 Future 对象 
Future<String> future = executorService.submit(callableTask); 
// 主线程可以继续执行其他操作 
...
// 获取 Callable 任务的执行结果，get() 方法会阻塞直到任务完成 
String result = future.get();
```
**wait和sleep**
wait是object类中的方法，只能用于同步代码块，退出时自动释放锁，必须被唤醒
sleep是Thread类中的静态方法，可以用于任何地方，使当前线程限时阻塞，持有锁时阻塞不会释放锁
**死锁，预防、避免、检测、解除**
死锁指线程间相互抢占资源导致所有线程都处于等待资源的情况
互斥：资源在同一时间只能被一个线程获取
请求与保持：线程在请求其他资源时不会释放已有资源
不可抢占：线程所持有的资源不会被其他线程抢占
环路等待：所有线程处于一种相互等待对方释放资源的情形
预防：一次能获取到所有资源时才获取；按层级获取和释放
避免：银行家算法
检测：进程-资源分配图是否有环路
解除：重启，逐个释放死锁线程，全部释放，抢占资源
# JVM
**JDK,JRE,JVM**
jdk功能齐全的javaSDK,包含JRE和编译器以及其他工具
jre是java运行时环境,包含jvm和java基础类库
jvm时java虚拟机,运行 Java 字节码的虚拟机
**java程序的编译，执行过程**
.java程序经javac命令编译成.class字节码文件
jvm加载字节码文件使用即时编译器JIT将字节码转换为机器码执行
**JVM的组成部分**
类加载器,运行时数据区,执行引擎和本地方法库
类加载器将字节码加载到内存中，创建class对象
运行时数据区存储运行时产生的各种数据
执行引擎将字节码翻译为底层系统指令再交由cpu运行,此时会调用本地方法库
**运行时数据区**
线程共享:堆,方法区
线程私有:栈,本地方法栈,程序计数器
**堆，栈，方法区，本地方法栈，程序计数器各自的作用**
堆:存储对象实例,是垃圾回收的主要区域
栈:以栈帧作为存储单元,存储局部变量表,操作数表,动态链接以及方法出口等信息
方法区:可以看作是堆的一部分,存储已被虚拟机加载的常量,静态变量以及即时编译的代码
本地方法栈:是java调用非java代码的接口,执行的是本地方法
程序计数器:保存当前线程所执行的字节码行数,jvm通过改变这个值来选取下一个执行的字节码指令,在线程切换时保存上下文信息,线程获取时间片时根据信息继续执行
**如果要在java程序中运行其它语言的代码，怎么办**
java中的本地方法栈可以调用其它语言的代码,java中用native关键字声明这些方法即可
**类加载的过程**
分为加载连接初始化
**加载**是类加载器将字节码文件加载到内存中（几种类加载器中分别定义了默认的加载文件，再结合双亲委派）,此时创建了类的class对象，其中保存了加载当前类的类加载器，可以用于后续操作（动态加载，卸载等））
**连接**分为验证准备解析
验证是保证加载类的准确性,是否符合jvm规范
准备是为类变量分配内存并设置类变量初始值(不是赋的值)
解析是将类中的符号引用转换为直接引用
**初始化**时堆内类的静态变量和静态代码块进行初始化操作
**类加载器**
常见的有四种,分别是启动,扩展,应用和自定义
启动类加载器,由C++编写,加载jre/lib下的类库
扩展类加载器,继承classloader,加载jre/lib/ext目录中的类库
应用类加载器,继承classloader,加载开发者自己编写的类
自定义类加载器,开发者可以继承classloader,实现自定义类加载规则(可以不采用双亲委派)
**双亲委派，好处**
一个类加载器收到了类加载请求,不会直接加载,而是先将这个请求委派给父类加载器执行,每个层级的类加载器都是这样,只有当父类加载器无法完成请求时,才会自己尝试加载
这样做的目的一是为了保证类不会被重复加载,二是为了保证java的核心类库api不被随意修改
**堆的结构，对象晋升的过程**
堆可以分为新生代和老年代,新生代又可以分为eden区和survivor区（S0,S1）
其中，永久代是方法区的一种实现（java7），属于堆的一部分
新创建的对象进入eden区（大对象直接进入老年代）
eden区或survivor区内存满了后进行minorGC（清理eden和surviovor），存活对象进入survivor区或年龄增长
老年代空间不足时进行majorGC
特殊情况下会进行fullGC，对整个堆进行垃圾回收（新生代，老年代，永久代，元空间）
**如何判断对象是否要被回收**
引用计数法：对象每有一个引用时，计数+1，引用数为0时变为垃圾（无法解决循环引用）
可达性分析法：从“GC Roots”（虚拟机栈中引用的对象、本地方法栈中引用的对象、方法区中静态属性引用的对象以及常量池中引用的对象）的根对象出发，沿着对象引用关系遍历整个对象图，标记所有能够被从GC Roots到达的对象，未标记的对象即被认为是不可达的，可以被回收
**四种引用**
强引用，软引用，弱引用，虚引用
强引用，必须且不可回收，垃圾回收时需要保留，即使抛出异常
软引用，不必须但不必回收，垃圾回收时可以回收，但内存空间充足时不必回收
弱引用，不必须且必须回收，内存空间不足时优先回收，充足时也可能回收
虚引用，相当于没有任何引用，任何时候都可能被回收，可以配合引用队列使用，在它进入引用队列后，将要删除之前，手动进行一些操作
**垃圾回收算法**
标记清除，标记整理，标记复制
分代回收（区分新生代和老年代的目的），可以针对性选择不同的算法
新生代中选择”标记-复制“算法，老年代选择“标记-清除”或“标记-整理”算法
**垃圾回收器**
是垃圾回收算法的具体实现
串行垃圾回收器，并行垃圾回收器(JDK8)，CMS并发，G1(JDK9)
parNew：运行于新生代，采用复制算法，响应速度优先
Parallel Scavenge：运行于新生代，采用复制算法，吞吐量优先
CMS:以最小停顿时间为目标，采用并发收集，标记-清除，运行于老年代
G1：回收停顿时间最短，没有明显缺点，采用标记-整理加复制算法，运行于both
**内存溢出（堆溢出，栈溢出）**
虚拟机栈溢出，一般由于方法递归StackOverflowError
java堆内存溢出，一般由于对象实例过多OutOfMemoryError
持续运行的服务器也不一定发生fullGC乃至OOM
**JVM内存参数**
--Xms\<size>:设置初始堆大小。
--Xmx\<size>: 设置最大堆大小。
--XX:+UsexxxGC: 使用哪种垃圾回收器
**对象的创建过程**
为实例对象分配内存，用构造器初始化成员变量，将实例对象指向分配的内存
单例模式双重校验锁变量需要用volatile修饰，上面三个步骤必须按顺序
# mysql
**事务四大特性**
原子:一次事务的所有操作要么全部执行,要么全都不执行
一致:事务只能将数据库从一个合法状态转移到另一个合法状态,不能破坏其完整性约束
隔离:一个事务的执行不能被其他事务干扰
持久:事务一旦提交，其结果将永久保存在数据库中，并对后续的事务是可见的
**事务的一致性补充**
事务的一致性是具体情况具体分析的。不同的业务场景可能有不同的一致性要求，而一致性的定义取决于业务的特点和需求。在银行转账的例子中，一致性主要强调了金额总数的一致性。但在其他业务场景中，一致性可能涉及到更多方面的数据和业务规则。一些其他可能的一致性要求包括：
1. **数据完整性：** 确保数据库中的数据符合定义的完整性规则，如唯一性约束、外键约束等。
2. **业务规则一致性：** 确保事务执行前后业务规则得到维护和满足，不违反业务逻辑。
3. **状态转变一致性：** 在状态转变时，确保数据库从一个合法状态转变为另一个合法状态，而不是介于两个状态之间的非法状态。
4. **并发操作一致性：** 在多个事务并发执行的情况下，确保数据库状态的一致性，避免并发操作导致的数据异常。
**三大范式**
列不可再分,非主键字段依赖于主键字段,非主键字段只依赖于主键字段
**多线程下处理数据可能出现的问题（为什么需要事务）**
各个线程的执行顺序不一致,可能出现脏读,幻读,不可重复读等问题
其中脏读是读取某个数据后有其他线程修改了这个数据导致读取了错误的数据
幻读是一个事务在某个时间点内读取了一组数据，然后另一个事务在这个时间点之后插入或删除了一些数据，导致第一个事务在时间点 t2 重新读取相同的数据集时，发现数据集发生了变化
不可重读是一个事务在某个时间点内多次读取同一行数据，但由于其他事务的修改，得到了不同的结果
**区分不可重读和幻读**
区分不可重复读和幻读的关键在于，不可重复读强调的是在同一行数据的读取过程中发生了数据的变更，而幻读强调的是在一组数据的读取过程中，由于另一个事务的插入操作导致了数据的变化。
**事务隔离级别**
读未提交:事务之间几乎没有隔离。一个事务可以读取到另一个事务尚未提交的修改
读已提交:保证一个事务提交后其他事务才能读取到修改的数据，支持行锁
可重复读:在同一事务中，保证相同查询的结果是一致的即使其他事务对数据进行了修改，支持行锁，间隙锁和临键锁
串行化:确保事务之间没有并发问题, 通过对读取和写入的数据加锁来实现
**innodb和myisam**
innodb相比于myisam多了几个特点,支持事务外键行级锁
**主键和外键的区别：**
1. **唯一标识：** 主键用于唯一标识表中的每一行记录，而外键用于建立表与表之间的关联关系。
2. **唯一性：** 主键的值必须是唯一的，而外键的值可以重复，但它们通常用于引用其他表的主键，因此在引用表中的外键列中的值应该是唯一的。
3. **NULL值：** 主键不能包含NULL值，而外键可以包含NULL值，表示关联表中没有匹配的主键。
4. **数目限制：** 每个表只能有一个主键，而可以有多个外键。
5. **作用：** 主键主要用于唯一标识记录，而外键用于建立表与表之间的关联关系，通过外键可以实现引用完整性，保持表与表之间的一致性。
**外键（Foreign Key）：**
- 外键是用于建立两个表之间关联的一列或一组列。
- 外键在一个表中引用另一个表的主键，用于定义表与表之间的关系。
- 外键的值可以为NULL，表示该行数据在关联表中没有匹配的主键。
- 外键用于维护表与表之间的引用完整性。
**mysql保证事务四大特性的原理**
原子性：由undolog保证，回滚时撤销已执行的sql
一致性：其它三大特性共同保证，是事务的目的
隔离性：由MVCC保证
持久性：redolog和内存（logbuffer）保证
**undolog和redolog**
undolog记录逻辑日志，事务回滚时进行逆操作恢复，保证事务的原子性和一致性
redolog记录数据页的物理变化，服务宕机用来恢复数据，保证事务的持久性
**MVCC及实现原理**
多版本并发控制，内含三个部分：隐藏字段（事务id，回滚指针），undolog，readView
事务id：最近修改的事务id，回滚指针配合undolog指向数据上一个版本
undolog：记录数据历史版本
readView：事务进行快照读时动态生成的视图，记录当前系统中活跃的事务id，控制哪个历史版本对事务可见
**mysql的默认隔离级别**
可重复读，分为快照读和当前读，通过间隙锁和临键锁解决了幻读问题
**快照读和当前读**
快照读：读取的是当前数据的可见版本，可能是过期数据
当前读：读取的是数据的最新版本，读的时候会上锁，不被其它事务并发修改
**索引的分类**
主键索引,唯一索引,普通索引,复合索引，全文索引（MyISAM）
**聚簇索引和非聚簇索引、回表查询**
聚簇索引是指索引和行数据存储在一起,通过索引能直接获取当前行的数据
非聚簇索引又称二级索引,索引和行数据不是存储在一起的,是在聚簇索引上创建的其它索引,需要先根据索引获取地址,再根据地址获取数据(回表查询)
**覆盖索引**
当前索引中含有所有需要查询的字段,查询速度较快
**为什么mysql采用B+树（B树，ASL，跳表）**
B+树层级较低，检索效率比较稳定，相对平衡，省去复杂的维护平衡开销
数据全部存储在叶子节点
叶子节点之间采用双向链表连接，适合范围查询
可以通过叶子节点的顺序访问来获取相邻的数据，并且一个节点存储多个键值，减少IO
**mysql的慢查询优化，如何定位慢查询**
mysql的配置文件中可以开启慢日志功能,可以设置将超过指定执行时间的sql记录到日志中,可以通过日志查看慢sql
可以通过查看执行计划explain来优化sql
**explain的常用字段**
key是否命中了索引
key_len表示索引的长度，即索引字段的最大字节数。数值越小，性能越好。
type扫描类型,可以判断是否有进一步优化空间all,index,range,ref等
rows估计必须要扫描的行数
extra是否出现了回表,尽量使用覆盖索引(修改返回字段,添加索引)
**sql语句优化方案**
字段:尽量减少字段或查询有索引的字段,用覆盖索引
where:条件使用索引(update时),使用聚合函数count时用count(\*)
limit：后面的数字大时先用子查询查找出主键再limit主键后n条数据
groupby和orderby都要使用索引
使用关联查询代替子查询,并尽量使用内连接,用小表驱动大表
(因为子查询和外连接会对驱动表进行全表扫描,内连接mysql会根据查询优化器判断用哪个表驱动)
表中数据太大时可以考虑分库分表
**内连接和外连接**
内连接是连接两个表，并返回满足连接条件的行。只有在连接条件成立的情况下，才会返回结果
外连接包括左外连接（Left Outer Join）、右外连接（Right Outer Join）和全外连接（Full Outer Join）。用于处理两个表之间存在不匹配的情况，它允许在某个表中找不到匹配行时，仍然保留另一个表中的数据。
- **左外连接（Left Outer Join）：** 返回左表中的所有行，以及右表中满足连接条件的行。如果右表中没有匹配的行，返回 NULL 值
- **右外连接（Right Outer Join）：** 返回右表中的所有行，以及左表中满足连接条件的行。如果左表中没有匹配的行，返回 NULL 值。
- **全外连接（Full Outer Join）：** 返回左表和右表中的所有行，如果没有匹配的行，返回 NULL 值。
**sql查询的过程**
客户端向mysql服务器发送查询请求
8.0前mysql会先查询缓存,8.0后不查询缓存
服务器进行sql解析,预处理,由优化器生成对应的执行计划
根据执行计划调用存储引擎的api执行查询
将结果返回给客户端
**索引失效的情况**
不满足最左匹配原则(最左匹配原则是指在复合索引中,查询条件中应该使用最左边的索引列以获得最大的性能提升)
模糊查询用%开头
索引字段参加了运算或者进行了类型转换
where条件中有or,除非所有条件字段都有索引,否则索引失效
mysql觉得全表扫描比索引更快时
**插入大量数据的优化**
1.InsertBatch在代码中批量插入
```
for (User user : userList) { 
	statement.setString(1, user.getName()); 
	statement.setInt(2, user.getAge()); 
	statement.addBatch(); 
}
// 执行批量插入 
statement.executeBatch();
```
2.直接在数据库中导入sql文件，LOAD DATA INFILE
3.数据量超大时可以分批次导入，禁用索引，多线程分批次插入
**mysql主从复制**
主库在事务提交时，将数据变更记录在binlog中
从库读取binlog，写入中继日志relaylog
从库根据relaylog改变自己的数据
**索引数目限制**
64
**字段数目限制**
4096
**mysql8新特性**
默认隔离级别RR--->RC；支持全文索引和空间索引；支持更大索引长度；更好的 JSON 支持
引入了窗口函数和分析函数，允许在查询中执行更复杂的分析和聚合操作，如 `ROW_NUMBER()`、`RANK()`、`LEAD()`、`LAG()` 等，移除缓存。
# redis
**redis为什么快**
基于C语言,数据结构简单
基于内存,基于IO多路复用
执行命令时是单线程的
**redis可以用来做什么**
分布式锁,缓存,消息队列
**redis常用的数据类型，底层数据结构**
string：SDS，更灵活和高效
list：压缩列表或双向循环链表
set：散列表或整数集合（intset）： 根据集合元素的大小和类型选择合适的底层结构
hash：散列表（数组加链表）
sortedset：跳表和散列表，实现相对简单，并且可以范围查询
**key的大小限制**
512M
**hash可以设置过期时间吗**
Hash 结构是不支持直接设置过期时间的。可以在使用 Hash 结构的同时，为包含该Hash 结构的 Key 设置过期时间。这样，当 Key 过期时，与之关联的 Hash 结构也将被删除。
**持久化策略**
分为RDB和AOF
RDB是一个快照文件,会将redis存储的数据写到磁盘上恢复时从RDB中获取数据
AOF记录的是每次redis修改时执行的命令,恢复时依次执行其中的命令
RDB是二进制文件,保存时体积较小,恢复比较快,但是可能会有数据丢失
AOF恢复速度慢一些,但是不太会丢数据,可以设置刷盘策略,固定时间批量写入命令
**数据淘汰策略**
报错，最近最少使用(LRU),最少频率使用(LFU)
**过期删除**
是定期删除和惰性删除结合的
定期删除是指redis定期检查key的过期时间,如果超过了就删掉
惰性删除是访问到这个key时发送它超过了过期时间就删除
**缓存穿透，缓存击穿，缓存雪崩**
缓存穿透:是指持续访问一个不存在的数据,因此不走缓存直接访问数据库,解决办法是缓存null值或者采用布隆过滤器
缓存击穿:大量请求访问同一个热点key,当这个key过期的瞬间,所有请求同时到达数据库,解决办法是使用互斥锁或者设置当前key逻辑过期;互斥锁是缓存失效时不立即访问数据库而是先去redis通过setnx获取一个互斥锁,可以保证数据的强一致性,但是可能造成死锁等问题,性能也不太好;逻辑过期是设置一个过期时间字段,查询时判断是否过期,如果过期了就另外开一个线程进行数据同步,先返回这个数据,不能保证数据的强一致性,但性能较高
缓存雪崩:多个key设置了相同的过期时间,缓存在某一时间全部失效,请求全部转发到数据库,解决办法是将过期时间分散开,在原有的失效时间加一个随机值
**布隆过滤器**
先初始化一个比较大的数组全部初始化为0,每个key经过三次hash运算并模数组长度可以得到三个数组下标,把这几个下标对应的位置改为1,这样每三个下标就可以确定一个key,当一个key需要进行查询时,先通过三次hash判断它是否存在
这种方法可能存在一定的误判,但一般5%是可以接受的
**mysql与redis的同步（双写一致性）**
使用读写锁,读的时候添加共享锁,写的时候添加排他锁,需要更改业务逻辑
采用canal,它伪装程mysql的一个从节点,mysql数据更新后,它会读取binlog数据,通过canal的客户端获取到数据更新缓存
**延迟双删**
写操作时,先将缓存中的数据删除,再更新数据库,最后再延时删除缓存中的数据,这个延时的具体时间不好确定,延时过程会产生脏数据,不能保证强一致性
**redis实现分布式锁，如何优化**
setnx
获取到锁线程异常中断：设置过期时间
是否是解自己的锁：设置唯一标记
判断标记是否是自己的和解锁不是原子性：使用lua脚本
业务逻辑时间长锁自动释放：redisson看门狗
**redisson看门狗**
获取锁的同时开启一个线程监视锁，每10s将锁的过期时间延长30s，直到锁释放该线程关闭，锁30s后释放，或者程序异常不再递归延长锁的时间
**集群方案（主从，哨兵，分片）**
主从：主节点负责写，从节点负责读
哨兵：在主从的基础上加上哨兵节点，当主节点宕机时，选举新的主节点
分片：多个主节点互为哨兵
**分片集群数据如何存储和读取**
有16384个哈希槽，每个主节点控制不同范围，每个key过来时通过hash映射到响应的哈希槽中，转发到对应的主节点
**脑裂**
哨兵模式中主节点与其它节点断联导致系统中不同的网络分区中有两个主节点
网络恢复后断联的主节点会成为另一个新主节点的从节点，导致数据丢失
解决方案是设置至少要有一个从节点才能作为主节点
**主从同步**
1.建立连接： 从节点与主节点建立连接，通过发送命令进行身份验证。
2.全量同步： 首次同步时，主节点将所有数据发送给从节点，完成从节点的初始化。这个过程称为全量同步（RDB 文件同步）。
3.增量同步：之后，主节点会将每次写操作的指令（命令）发送给从节点，从节点只需执行这些指令即可保持同步。这个过程称为增量同步（AOF 文件同步）。
**大key和热key问题**
大key：
- 将大的值拆分成多个小的值。
- 如果是字符串类型，可以考虑使用列表（List）或分块存储。
- 注意定期清理不再需要的大 Key。
热key：
- 分片（Sharding）：将数据分散到多个 Redis 节点上，减轻单个节点的负载。
- 使用缓存淘汰策略，如 LRU（Least Recently Used）策略，自动清理不经常使用的 Key。
- 考虑使用 Redis Sentinel 或 Redis Cluster 来实现高可用性，保证故障转移和负载均衡。
- **数据预热：** 在系统启动或负载较低的时候，预先将热key的数据加载到缓存中，避免在高负载时再进行数据库查询。这可以通过定期任务或系统启动时的批量操作来完成。
- **使用异步处理：** 对于热key的写操作，可以考虑使用异步处理，将写操作放入消息队列中异步执行，以减轻实时写操作对系统的影响。
- **数据库优化：** 对于热key所在的数据库表，可以考虑对其进行优化，例如使用索引、分表等方式，以提高数据库查询性能。
- **负载均衡：** 如果热key导致某个节点负载过高，可以考虑使用负载均衡技术，将请求分散到多个节点上，避免单一节点的性能瓶颈。
# 框架
**常用注解**
**IOC和AOP**
IOC：控制反转，将创建和管理bean从程序员手中交给容器，统一管理，即取即用
AOP：面向切面编程，将于业务逻辑无关而多次使用的代码抽取出来单独放在一个类中，实现代码解耦，复用
**springAOP的实现**
基于动态代理，静态代理与动态代理见java基础
**spring的事务**
分为编程式和声明式，一般使用声明式，在方法上加@Transactional注解，这个方法中的sql会统一成功或失败，原理是spring会生成这个类的代理对象作为bean，将事务自动提交设为false
**事务失效**：
事务方法类不在容器中，
事务方法不是public，
业务自己捕获并处理了异常没有抛出，
同一个类中没有添加事务的方法调用添加事务的方法，
spring默认只回滚运行时异常，需要通过rollbackfor属性设置
**事务的传播行为**通过propagation属性设置
发生在一个事务方法调用另一个带事务的方法时
1. **REQUIRED（默认）：**
    - 如果当前没有事务，就新建一个事务。如果存在一个当前事务中，加入该事务。这是最常见的选择。
2. **SUPPORTS：**
    - 支持当前事务，如果没有当前事务，就以非事务方式执行。
3. **MANDATORY：**
    - 使用当前的事务，如果当前没有事务，就抛出异常。
4. **REQUIRES_NEW：**
    - 新建事务，如果当前存在事务，把当前事务挂起。
5. **NOT_SUPPORTED：**
    - 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
6. **NEVER：**
    - 以非事务方式执行，如果当前存在事务，则抛出异常。
7. **NESTED：**
    - 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行类似于 `REQUIRED` 的操作。
**spring中的设计模式**
BeanFactory工厂模式，AOP代理模式，RestTemplate模板方法模式
MVC中handlerAdapter适配器模式，监听器观察者模式
**bean的生命周期，循环依赖（三级缓存），构造方法中的循环依赖**
实例化，属性赋值，初始化，销毁
BeanDefiniton存放bean的各种信息
bean自身的方法（init-method，destory-method）
可以通过aware接口或postProcessor进行拓展
循环依赖是指AB两个bean互相依赖对方，创建A实例时包含B属性实例，创建B实例时包含A属性实例，通过三级缓存解决
一级缓存：单例池，缓存已经初始化完成的bean
二级缓存：半成品池，缓存还未初始化完成的bean
三级缓存：缓存objectFactory对象工厂
A创建时，生成objectFactory存入三级缓存，依赖属性B，于是先去创建B，B生成objectFactory存入三级缓存，并从三级缓存中通过A的对象工厂获取其普通或代理对象，这个对象放入二级缓存，B完成属性赋值和初始化，放入一级缓存，A从一级缓存中获取B对象完成属性赋值和初始化，最后移除二级缓存中的临时对象（二级缓存的目的是为了知道有哪些bean还没有初始化完成，稍后要继续）
如果是构造方法中的循环依赖，可以用@Lazy采用懒加载的方式，等用到时再加载
**bean是线程安全的吗**
不是线程安全的，多用户请求同一服务时，容器会给每个请求分配一个线程，如果线程中有对单例状态的修改，则要考虑线程同步问题。
但一般使用的bean（DAO，service）都是不可变的状态，是线程安全的
如果bean有多种状态，则需要保证线程安全，如将作用域改为prototype
**@Component和@Bean**
1.用途不同
@Component用于标识普通的类
@Bean是在配置类中声明和配置Bean对象
2.使用方式不同
@Component是一个类级别的注解，spring通过@Component注解扫描并注册为Bean
@Bean通过方法级别的注解使用，在配置类中手动声明和配置Bean
3.控制权不同
@Component注解修饰的类是由spring来创建和初始化的
@Bean注解允许开发人员手动控制Bean的创建和配置过程
**@Autowired和@Resource**
@Autowired是Spring框架提供的注解，默认按照类型进行匹配，可以用于构造器、属性、方法的注入，支持可选属性注入（允许某个属性为null）
@Resource 是Java EE（Java Platform, Enterprise Edition）规范中的注解，默认按照属性名进行匹配，可以用于属性和方法的注入，但不支持构造器注入，不支持可选属性注入
**bean的作用域**
用@Scope注解指定
单例（singleton）在整个应用中只创建一个 Bean 实例
原型（prototype）每次请求时都创建一个新的 Bean 实例
请求（request）一次 HTTP 请求中，创建一个 Bean 实例
会话（session）用户会话中创建一个 Bean 实例
全局会话（Global Session ）类似于 Session 作用域，但用于 Portlet 环境
应用（application）在整个 Web 应用的生命周期中创建一个 Bean 实例
后四个作用域是在 Web 环境下使用的
**springMVC执行流程**
几个关键的组件DispatcherServlet前端控制器调度中心
HandlerMapping处理器映射器，HandlerAdapter处理器适配器，Controller/Handler具体处理器，ViewReslover视图解析器，还有传递的ModelAndView和View对象
DispatcherServlet--->HandlerMapping--->Handler及其拦截器（如果有）返回
DispatcherServlet--->HandlerAdapter--->Handler返回ModelAndView
DispatcherServlet传递ModelAndView给ViewReslover解析后返回View
DispatcherServlet根据View渲染后响应用户
现在的前后端分离项目直接在Handler处返回Response给前端了（没有第三步）
**springboot自动配置原理**
启动类上注解springbootApplication包含三个注解
springbootConfiguration、EnableAutoConfiguration、ComponentScan
其中EnableAutoConfiguration用于开启自动配置，它通过import注解导入对应的配置选择器，内部读取了该项目和该项目引用的jar包下的classpath路径下的METE-INF/spring.factories文件中配置的类的全类名，这些配置类所定义的bean根据条件注解指定的条件决定是否注入spring容器
**mybatis执行流程，延迟加载（懒加载）及底层原理**
读取配置文件mybatis-config.xml加载运行环境和映射文件
构建会话工厂SqlSessionFactory（单例）
创建SqlSession对象，含有执行sql的所有方法
操作数据库接口，Executor执行器，同时负责查询缓存的维护
Executor有一个MappedStatement参数封装映射信息
输入参数映射，输出结果映射
mybatis支持一对一和一对多关联集合对象的延迟加载
配置文件中可以配置启用，默认是关闭的（lazyLoadingEnabled）
底层使用的是CGlib动态代理
创建目标对象（开启了延迟加载的mapper）的代理对象
调用目标方法是进入拦截器invork方法，目标方法是null时再执行sql查询
获取数据后调用set方法设置属性值再继续查询目标方法
**mybatis一、二级缓存**
一级缓存是SqlSession级别的缓存，它默认是开启的。在同一个SqlSession中，如果执行了相同的SQL语句，则第一次查询的结果会被缓存到一级缓存中，后续再执行相同的SQL语句时，会直接从缓存中取得结果，而不再去数据库查询。生命周期短：一级缓存的生命周期是与SqlSession绑定的，SqlSession关闭后，缓存失效。本地作用域：一级缓存是SqlSession本地的，不同的SqlSession之间的缓存不共享
二级缓存是Mapper级别的缓存，它可以被多个SqlSession共享。当一个Mapper执行查询时，查询结果会被放入到该Mapper对应的二级缓存中，其他Mapper可以从二级缓存中获取数据，避免重复查询数据库。生命周期长：二级缓存的生命周期是整个应用程序的，它在不同的SqlSession之间共享。跨Session共享：不同的SqlSession可以共享同一个Mapper的二级缓。如果开启了二级缓存，对应的实体类需要实现序列化接口。在Mapper.xml文件中，可以通过配置来开启或关闭二级缓存。当某个作用域（一级缓存Session，二级缓存namespace）进行新增，删除，修改后，默认该作用域下的所有select中的缓存删除
# 设计模式
**1. 单例模式：**
    - 目的：确保一个类只有一个实例，并提供全局访问点。
    - 实现：通过私有化构造方法，提供一个静态方法返回唯一实例。
2. **工厂模式：**
    - 目的：将对象的创建和使用分离，通过工厂方法创建对象。
    - 实现：定义一个接口，多个实现类，由工厂类根据条件创建具体实例。
3. **策略模式：**
    - 目的：定义一系列算法，封装每个算法，并使它们可互换。
    - 实现：创建一个策略接口，多个实现类代表不同算法，Context类使用其中之一。
4. **责任链模式：**
    - 目的：将请求的发送者和接收者解耦，多个对象按顺序处理请求。
    - 实现：每个处理者持有下一个处理者的引用，请求依次传递，直到有处理者处理为止。
spring中使用的设计模式
1. **单例模式（Singleton Pattern）：** Spring容器默认使用单例模式管理Bean，确保在一个容器中只有一个实例。这有助于减少资源消耗，提高性能。
2. **工厂模式（Factory Pattern）：** Spring使用工厂模式创建和管理Bean，通过配置文件或注解指定Bean的创建方式，将实例化的过程交给Spring容器处理。
3. **代理模式（Proxy Pattern）：** Spring AOP（面向切面编程）使用代理模式，允许在不修改源代码的情况下，通过动态代理添加额外的横切关注点。
4. **观察者模式（Observer Pattern）：** Spring的事件驱动机制就是基于观察者模式实现的。应用程序可以发布事件，而监听器（观察者）可以订阅并响应这些事件。
5. **模板模式（Template Pattern）：** Spring的JdbcTemplate等模块使用模板模式，定义了算法骨架，将某些步骤的实现留给子类或回调函数。
6. **策略模式（Strategy Pattern）：** Spring中的各种接口和实现类的设计，例如BeanPostProcessor、ApplicationContext等，允许选择不同的实现策略。
7. **装饰者模式（Decorator Pattern）：** Spring的AOP中，通过装饰者模式实现切面的织入。
8. **适配器模式（Adapter Pattern）：** Spring的适配器模式通过适配器（例如HandlerAdapter）允许不同的组件协同工作。
9. **建造者模式（Builder Pattern）：** Spring中的BeanDefinitionBuilder等用于构建复杂对象，提供了流畅的API。
10. **迭代器模式（Iterator Pattern）：** Spring的集合类（如List、Map）提供了迭代器，支持对集合元素的遍历。
# Linux
ls命令：列出当前目录中的文件和文件夹
cd命令：更改当前工作目录
pwd命令：显示当前工作目录的路径
mkdir命令：创建一个新目录
rm命令：删除文件或目录
cp命令：复制文件或目录
mv命令：移动文件或目录
cat命令：查看文件内容
grep命令：搜索文件内容
top命令：显示当前正在运行的进程和系统资源使用情况
find命令：搜索文件或目录
tar命令：打包和解压文件
ssh命令：远程登录到另一台计算机
scp命令：在计算机之间传输文件
ps命令：显示当前正在运行的进程
chmod命令：修改文件的权限
netstat命令：查看端口占用情况
lsof -i :8080：查看具体端口被哪个进程占用
kill命令：终止正在运行的进程
ping命令：测试计算机之间的网络连接
ifconfig命令：显示当前计算机的网络接口配置