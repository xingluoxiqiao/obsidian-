哈希表指的是一种可以根据关键码的值而直接进行访问的数据结构，也就是将数据与确定的数值（关键码如键值，下标等）进行绑定从而简化查询的一种数据结构，常常用于**快速判断一个元素是否出现在集合里**
一般所说的哈希表包括数组，set和map
例如，要在某个集合或数组中查询某个数据，利用哈希表的思想，一边遍历，一边为其添加索引或下标（用新的哈希表将遍历过的数据都装起来），这样如果后面这些数据还要使用就可以直接从哈希表中获取了
# 有效的字母异位词
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词（只有小写字母，并且除了字母的位置之外，类型，个数都一样，如acaf和aafc）。

这题的关键就是将字符串中的字母个数用哈希表的方式存储起来，而字母的ascii码是连续的，并且字母的种类数也比较少，因此这里可以用数组来存储
```
public boolean isAnagram(String s, String t){
	int[] record = new int[26];
	for(int i=0;i<s.length;i++){
		record[s.charAt(i)-'a']++;
	}
	for(int j;j<t.length;j++){
		record[j.charAt(j)-'a']--;
	}
	for(int count : record){
		if(count !=0){
			return false;
		}
	}return true;
}	
```
# 两个数组的交集
给定两个数组，写一个方法返回两个数组的交集，要求去重

由于数据集可能有非常大的跨度，并且没有给出范围限制，无法用数组来存储，并且题目要求去重，可以用hashSet来实现
```

public int[] intersection(int[] nums1, int[] nums2) {
	if (nums1 == null || nums1.length == 0 || nums2 == null || nums2.length == 0) {
        return new int[0];
    }
    Set<Integer> set1 = new HashSet<>();
    Set<Integer> resSet = new HashSet<>();
    //遍历数组1
    for (int i : nums1) {
        set1.add(i);
    }
    //遍历数组2的过程中判断哈希表中是否存在该元素
    for (int i : nums2) {
	    if (set1.contains(i)) {
            resSet.add(i);
        }
    }
    return resSet.stream().mapToInt(x -> x).toArray();
}
```
# 两数之和
给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** _`target`_  的那 **两个** 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。

先确定一个数a，则题目转化为判断另一个数target-a是否在数组中出现过，因此采用哈希表得方法，由于要返回数组下标，因此用map的key来存储值，value来存储下标
```
public int[] twoSum(int[] nums, int target) {
    int[] res = new int[2];
    if(nums == null || nums.length == 0){
        return res;
    }
    Map<Integer, Integer> map = new HashMap<>();
    for(int i = 0; i < nums.length; i++){
        int temp = target - nums[i];   // 遍历当前元素，并在map中寻找是否有匹配的key
        if(map.containsKey(temp)){
            res[1] = i;
            res[0] = map.get(temp);
            break;
        }
        map.put(nums[i], i);    // 如果没找到匹配对，就把访问过的元素和下标加入到map中
    }
    return res;
}
```
# 三数之和
给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请
你返回所有和为 `0` 且不重复的三元组。
注意：答案中不可以包含重复的三元组。

很容易想到先用两层循环确定两个值a和b，再判断target-a-b是否在数组中，但这样采用哈希表的方法去重起来非常困难，因此可以采用双指针的方法，先为数组排序后，确定一个数a，再将两个指针分别指向a的后一个数和数组的最后一个数，三数之和过大时，right左移，三数之和过小时，left右移，这样的查重比较简单：根据a，b，c的运行顺序（a，b右移，c左移），只要下一个数与当前数相等时跳过下一个数即可去重
有几个注意点：
1.剪枝：对本题来说，只要最左侧的值大于0，就不可能再有解
2.去重时机：对a来说，循环的每一轮开始时即可判断
对b和c，必须已经有解后才判断是否需要去重（因为没有解的时候不需要去重，本来也不会进入结果集）
```
class Solution {  
    public List<List<Integer>> threeSum(int[] nums) {  
        Arrays.sort(nums);  
        List<List<Integer>> result=new ArrayList<>();  
        for(int i=0;i<nums.length;i++){  
            if(nums[i]>0) return result;  
            if(i>0&&nums[i]==nums[i-1]) continue;  
            int left=i+1;  
            int right=nums.length-1;  
            while(right>left){  
                int sum=nums[i]+nums[left]+nums[right];  
                if(sum <0){  
                    left++;  
                }else if(sum>0){  
                    right--;  
                }else{  
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));  
                    while (right > left && nums[right] == nums[right - 1]) right--;  
                    while (right > left && nums[left] == nums[left + 1]) left++;  
                      
                    right--;   
                    left++;  
                }  
            }  
        }  
        return result;  
    }  
}
```
# 四数之和
给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请
你返回所有和为 `0` 且不重复的三元组。
注意：答案中不可以包含重复的三元组。

这题的思路与三数之和相近，只是多了一层循环多确定了一个数的值
同时剪枝时的条件也有所区别，因为target和数组中的值均可能为负数，所以不能草率的用数组中某个值大于target来作为条件，而应该是均为正值时才行
```
class Solution {  
    public List<List<Integer>> fourSum(int[] nums, int target) {  
        Arrays.sort(nums);  
        List<List<Integer>> result=new ArrayList<>();  
        for(int j=0;j<nums.length;j++){  
            if (nums[j] > 0 && nums[j] > target) {  
                return result;  
            }  
            if(j>0&&nums[j]==nums[j-1]) continue;  
            for(int i=j+1;i<nums.length;i++){  
                if(i>j+1&&nums[i-1]==nums[i]) continue;  
                int left=i+1;  
                int right=nums.length-1;  
                while(right>left){  
                    int sum=nums[i]+nums[j]+nums[left]+nums[right];  
                    if(sum <target){  
                        left++;  
                    }else if(sum>target){  
                        right--;  
                    }else{  
                        result.add(Arrays.asList(nums[i],nums[j], nums[left], nums[right]));  
                        while (right > left && nums[right] == nums[right - 1]) right--;  
                        while (right > left && nums[left] == nums[left + 1]) left++;  
                          
                        right--;   
                        left++;  
                    }  
                }  
            }  
        } return result;  
    }  
}
```
# 四数相加
给你四个整数数组 `nums1`、`nums2`、`nums3` 和 `nums4` ，数组长度都是 `n` ，请你计算有多少个元组 `(i, j, k, l)` 能满足：
- `0 <= i, j, k, l < n`
- `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`
先将前两个数组中可能获得的相加的结果保存起来，再从后两个数组中可能获得的相加的结果中找相反数（2+2的复杂度是O2，1+3的复杂度是O3）
这题用哈希表的方法来做，关键在于要想到用map，因为不仅仅需要保存相加的结果，还需要保存这个结果出现的次数，getOrDefault方法获取指定键的值，如果键不存在，则返回默认值0
```
class Solution {
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        int res = 0;
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        //统计两个数组中的元素之和，同时统计出现的次数，放入map
        for (int i : nums1) {
            for (int j : nums2) {
                int sum = i + j;
                map.put(sum, map.getOrDefault(sum, 0) + 1);
            }
        }
        //统计剩余的两个元素的和，在map中找是否存在相加为0的情况，同时记录次数
        for (int i : nums3) {
            for (int j : nums4) {
                res += map.getOrDefault(0 - i - j, 0);
            }
        }
        return res;
    }
}
```