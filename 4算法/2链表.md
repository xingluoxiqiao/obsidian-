# 移除链表中的元素
一般有两种方法，一种是直接在原链表的基础上移除元素，但是这样就必须判断当前要移除的元素是否是头结点，因为头结点和其它结点的移除方式是不同的；另一种方法是采用虚拟头结点，可以保持移除方式的统一，下面以虚拟头结点的方法给出伪代码
```
dummyhead=new node();
dummy.next=head;
cur=dummyhead;
while(cur.next!=null){
	if(cur.next.val==target)
		cur.next=cur.next.next;
	else 
		cur=cur.next;
}return dummyhead.next;
```

# 设计链表（增删改）
```
class ListNode{  
    int val;  
    ListNode next;  
    public  ListNode(){}  
    public ListNode(int val){  
        this.val=val;  
    }  
}  
  
 class MyLinkedList {  
    private int size;  
    private ListNode head;  
    public MyLinkedList() {  
        size=0;  
        head=new ListNode(0);  
 }  
   public int get(int index) {  
         //如果index非法，返回-1  
         if (index < 0 || index >= size) {  
             return -1;  
         }  
         ListNode currentNode = head;  
         //包含一个虚拟头节点，所以查找第 index+1 个节点  
         for (int i = 0; i <= index; i++) {  
             currentNode = currentNode.next;  
         }  
         return currentNode.val;  
     }  
  
    public void addAtHead(int val) {  
       addAtIndex(0,val);  
    }  
  
    public void addAtTail(int val) {  
        addAtIndex(size,val);  
    }  
  
   public void addAtIndex(int index, int val) {  
        if(index>size){  
            return;  
        }  
        size++;  
        if(index<=0){  
            ListNode newhead=new ListNode();  
            newhead.val=val;  
            newhead.next=head;  
        }  
        ListNode newnode=new ListNode(val);  
        ListNode currentNode=head;  
        for(int i=0;i<index;i++){  
            currentNode=currentNode.next;  
        }  
        newnode.next=currentNode.next;  
        currentNode.next=newnode;  
    }  
  
    public void deleteAtIndex(int index) {  
        if(index>=size||index<0){  
            return;  
        }  
        size--;  
        if (index == 0) {  
            head = head.next;  
            return;  
        }  
        ListNode currentNode = head;  
        for (int i = 0; i < index; i++) {  
            currentNode = currentNode.next;  
        }  
        currentNode.next = currentNode.next.next;  
    }  
}
```
# 反转链表
给定一个链表，要求将这个链表反转后返回新链表的头节点
有两种写法，一种是双指针法，另一种是递归法，递归法建立在双指针法的基础上，理解了前者后者才更好理解
```
//双指针法
pre=null;
cur=head;
while(cue){
	temp=cur.next;
	cur.next=pre;
	pre=cur;
	cur=temp;
}return pre;

//递归法
reverse(node,node){
	if(cur==null) {return pre;}
	temp=cur.next;
	cur.next=pre;
	reverse(temp,cur);
}
reverseList(node head){
	retuen reverse(head,null);
}
```
# 两两交换链表中的结点
给定一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。
本题的关键是while循环中的条件，思路不清晰的话很容易产生空指针异常
```
dummyhead=new node();
dummyhead.next=head;
cur=dummyhead;
//顺序不能搞错，否则可能会产生空指针异常
while(cur.next!=null&&cur.next.next!=null){
	temp=cur.next;
	//cur.next.next.next即使为空也没关系
	temp1=cur.next.next.next;
	cur.next=cur.next.next;
	cur.next.next=temp;
	temp.next=temp1;
	cur=cur.next.next;
}
```
# 删除链表中倒数第n个结点
还是双指针的思想，快慢指针都从虚拟头节点触发，快指针先走n+1个结点后慢指针出发，当快指针走到链表末尾时，慢指针刚好走到倒数第n个结点的前一个结点
```
dummyhead=new node();
dummyhead.next=head;
fast=dummyhead;
slow=dummyhead;
for(int i=0;i<n;i++){
	fast=fast.next;
}
while(fast!=null){
	fast=fast.next;
	slow=slow.next;
}
slow.next=slow.next.next;
return dummyhead.next;
```
# 环形链表
判断一个链表中有没有环，如果有，找出环的入口
让快指针的速度是慢指针的速度的两倍，同时出发，快慢指针必定在慢指针进入环的第一圈相遇，经过简单的数学推导可以得出链表头节点到环的入口的距离等于环中相遇处到入口的距离的整数倍，从而可以得到环的入口
```
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) {// 有环
                ListNode index1 = fast;
                ListNode index2 = head;
                // 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口
                while (index1 != index2) {
                    index1 = index1.next;
                    index2 = index2.next;
                }
                return index1;
            }
        }
        return null;
    }
}
```