# 二分查找
给定顺序排列的数组，获取目标数值target的下标，否则返回-1
先确定区间的边界是闭还是开，在写代码时才能更好的处理边界值
```
//伪代码(左闭右闭)
left=0;
right=array.size-1;
while(left<=right){
	middle=(left+right)/2;
	if(array[middle]>targrt) right=middle-1;
	else if(array[middle]<target) left=middle+1;
	else return middle;
}
return -1;
```

# 移除元素
在给定的数组中移除值与给定值val相同的元素，最终返回新数组的长度（删除元素后的数组长度）
暴力解法是采用两层循环，不赘述
双指针法是数组算法中的一个常见而重要的思路，其本质是因为数组在物理空间上是连续的，因此可以用连续自增的变量（即下标）来替代循环，从而降低时间复杂度
```
//伪代码
fast=0;
slow=0;
for(fast=0;fast<array.size;fast++){
	if(array[fast] != val){
		array[slow] = num[fast];
		slow++;
	}
}
return slow;
```

# 有序数组的平方（含负数）
将给定有序数组中每一个元素平方后的值排列成新的有序数组后输出
还是采用双指针的思路，从两端向中间靠近，因为最大值只可能出现在两端
```
//伪代码
int [] result;
k=array.size-1;
for(int i=0,j=array.size-1; i<=j; ){
	if(array[i]*array[i] > array[j]*array[j]){
		result[k--]=array[i]*array[i];
		i++;
	}else{
		result[k--]=array[j]*array[j];
		j--;
	}
}
return result;
```

# 滑动窗口
给定一个数组，要求寻找数组中长度最短的子数组，使其所有元素的和小于给定值S，返回这个最小长度
本质上也是双指针的思路，在这里用滑动窗口形容更好理解，难点在于弄清楚起点位置应如何随重点位置移动，并且应该是持续移动直到满足条件
```
result=array.size;
i=0;//起点位置
for(int j=0;j<=array.size;j++){//终点位置
	sum+=array[j];
	while(sum>=S){//持续判断，而不是仅判断一次
		currrent=j-i+1;
		result=min(result,current);
		sum=sum-array[i];
		i++;
	}
}return result;
```

# 螺旋矩阵
给定一个整数n，将1到n的平方按螺旋矩阵的方式输出成二维数组
最重要的是要有统一的边界处理条件
可以将该矩阵看作一层层的，先填满外层，再往内层填，方向可以通过对横纵坐标的增减事先定义好
```
int[][] ans = new int[n][n];
int t = 0;
//定义横纵坐标的变化值，也就是运动的方向
int[] dx = {0, 1, 0, -1}, dy = {1, 0, -1, 0};
for (int i = 0, j = 0, k = 1; k <= n * n; ++k) {
    ans[i][j] = k;
    int x = i + dx[t], y = j + dy[t];
    if (x < 0 || x >= n || y < 0 || y >= n || ans[x][y] != 0) {t = (t + 1) % 4;}
    i += dx[t];
    j += dy[t];
}
return ans;
```
```