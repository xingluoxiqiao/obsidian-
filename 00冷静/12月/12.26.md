# 万得面经
线程池的原理  七大参数，拒绝策略，线程创建时间节点
HashMap如何去重 键是唯一的（哈希保证）
重写重载的区别 
如何创建单个线程 四种
Runnable和Calleable区别
单例模式饿汉式懒汉式（懒汉式想手撕源码但不会） 
快速排序底层（这个也答不上来）分治法和递归
Sql啥时候不适合用索引 表经常更新删除，字段的可选值很少，全表更快 
分页查询limit如何使用，从哪一页到哪一页怎么写 
内连接和外连接的区别 
事务的隔离级别 
不可重复读和幻读的区别  不可重复读是针对某一行数据，幻读是表中某个范围内的数据



1，编程六大原则  
- **单一职责原则（Single Responsibility Principle，SRP）：**
    - 一个类应该只有一个引起变化的原因，即一个类应该只有一个职责。
- **开放/封闭原则（Open/Closed Principle，OCP）：**
    - 软件实体（类、模块、函数等）应该**对扩展开放，对修改关闭**。即在不修改现有代码的情况下，通过添加新代码来扩展功能。
- **里氏替换原则（Liskov Substitution Principle，LSP）：**
    - 所有引用基类的地方必须能够透明地使用其子类的对象，即子类必须能够替换掉父类而不影响程序的正确性。
- **接口隔离原则（Interface Segregation Principle，ISP）：**
    - 不应该强迫一个类实现它不需要的接口。一个类只应该实现它需要的接口。
- **依赖倒置原则（Dependency Inversion Principle，DIP）：**
    - 高层模块不应该依赖于低层模块，二者都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。
- **合成/聚合原则（Composition/Aggregation Principle）：**
    - 聚合关系应该用于表示整体与部分的关系，而不是用于表示对象的包含关系。
2，ascii unicode utf8关联  
ascii是字符编码标准，unicode是字符集，UTF-8是对unicode编码
3,  红黑树和平衡二叉树  
- **平衡二叉树：**
    - 平衡二叉树是一种二叉搜索树，具有平衡性质，即左右子树的高度差不超过1。确保了在最坏情况下，查找、插入、删除等操作的时间复杂度都是O(log n)。
- **红黑树：**
    - 红黑树是一种自平衡的二叉搜索树，通过引入颜色标记（红色或黑色）和一些规则来保持树的平衡。红黑树的插入、删除等操作也能够保持O(log n)的时间复杂度。
4,  说一下treemap  
基于红黑树实现，可通过自然排序或自定义排序器排序
5、synchorized 原理，功能，应用场景  
- **功能：**
    - 实现线程同步，确保多个线程对共享资源的安全访问。
- **应用场景：**
    - 在多线程环境中对共享资源进行读写操作时，使用synchronized确保线程安全。
    - 保护关键代码段，防止多线程同时执行导致的数据不一致问题。
锁升级：
- **偏向锁：**
    - 当一个线程获得锁后，会在对象头部记录获取锁的线程ID。如果在之后锁的竞争中，没有其他线程来竞争这个锁，那么持有偏向锁的线程将继续持有这个锁，减少了锁的竞争。
- **轻量级锁：**
    - 当多个线程尝试获取同一个锁时，偏向锁会升级为轻量级锁。轻量级锁使用CAS操作来尝试获取锁，减少了传统锁使用的互斥量的开销。
- **重量级锁：**
    - 当多个线程尝试获取同一个锁，且CAS操作失败多次，锁会升级为重量级锁。重量级锁使用互斥量来保护共享资源，保证了多个线程之间的互斥。
java对象头：
1. **Mark Word（标记字段）：**
    - Mark Word是对象头的一部分，占用64位。它包含了一系列的标志位，用于存储对象的状态信息，例如锁状态、GC状态等。其中的信息包括：
        - 对象的哈希码（identity hashcode）
        - 对象的分代年龄（用于分代垃圾回收）
        - 锁标记位（用于表示对象是否被锁定）
2. **Class Metadata Address（类型指针）：**
    - 指向对象的类元数据的指针。通过这个指针，JVM可以确定对象属于哪个类，从而可以调用相应的方法等。
3. **数组长度（仅针对数组对象）：**
    - 如果对象是一个数组，对象头还会包含数组的长度信息。


- 经典八股说说面向对象，三特性具体体现
- **封装：** 将对象的状态和行为封装在一起，对外部隐藏实现细节。
- **继承：** 允许一个类继承另一个类的特征和行为。
- **多态：** 允许同一操作作用于不同的对象，产生不同的行为。
- i ++ 和 ++ i 的区别
- continue、break、return 的区别
- String、StringBuilder、StringBuffer 的区别
- JVM 的组成结构
类加载器，运行时数据区，执行引擎，本地接口
- JVM 的运行时数据区，静态变量放在哪儿？
运行时数据区：（程序计数器，本地方法栈，虚拟机栈）（java堆，方法区）
静态变量存放在方法区
- MySQL 中使用什么关键字，去分析SQL语句的执行情况
explain常用的字段：key实际用到的索引，index是否用到覆盖索引，type扫描类型
- 场景题：假设现在有编号从 1 到 1000 万的数据，嗯，乱序的分布在一个文本里面，大概也有10多GB。你能快速的从这些文本里面找到编号组 1 - 10。有什么好的想法？(内存不足以一次性放下所有数据，不能使用常规中间件，自行实现)
外部排序加归并排序
### 二面：

- 经典八股：HashMap 和 TreeMap 区别，
- **HashMap：** 无序，基于哈希表实现，查询、插入、删除平均时间复杂度 O(1)。
- **TreeMap：** 有序，基于红黑树实现，查询、插入、删除平均时间复杂度 O(log n)。
- 底层实现？复杂度？为什么不使用AVL,而使用红黑树     AVL 和 红黑树的区别？
- MySQL 索引：主键索引与非主键索引的区别索引的底层实现
- 索引优化
- BIO、NIO、AIO
1. **BIO（Blocking I/O）：**
    - 同步阻塞 I/O 模型，每个连接都需要独立的线程进行处理。
    - 适用于连接数较小且连接时间较短的情况。
2. **NIO（Non-blocking I/O）：**
    - 同步非阻塞 I/O 模型，通过单线程处理多个连接，使用选择器（Selector）实现事件驱动。
    - 适用于连接数较多且连接时间较长的情况。
3. **AIO（Asynchronous I/O）：**
    - 异步非阻塞 I/O 模型，通过异步通知的方式处理 I/O 事件。
    - 适用于连接数多且连接时间较长，且对性能要求较高的场景。

2. 面向对象的特点  
3. ArrayList 与 LinkedList 区别  
4. ConcurrentHashMap 实现线程安全的原理  
1. **分段锁机制：**
    - `ConcurrentHashMap` 将哈希表分成多个段（Segment），每个段独立地维护一部分数据。每个段都有自己的锁。这种分段锁机制有效地减小了锁的粒度，提高了并发度，不同段的操作可以并发进行，从而提高了整体性能。
2. **Segment的数据结构：**
    - 每个 Segment 内部使用类似于 HashMap 的数据结构，它包含一个数组，数组的每个元素是一个链表或红黑树。每个 Segment 独立维护自己的数据结构，这些数据结构在读操作时无需加锁，只在写操作时进行加锁。
3. **操作分离：**
    - `ConcurrentHashMap` 将不同的操作进行了分离。读操作通常不需要加锁，可以并发进行，而写操作通过分段锁的机制，保证同一时刻只有一个线程进行写入。
4. **Resize机制：**
    - `ConcurrentHashMap` 在扩容时，只会对其中的一个 Segment 进行扩容，而不是对整个表进行扩容。这样减小了扩容时锁的持有时间，提高了并发性能。
5. 如何创建一个线程  
6. 消息队列的应用  
7. int 可以表示范围为什么是-2147483648 到 2147483647（怀疑在羞辱我）  
8. 个人的优势（对比他人）  
9. 个人的劣势  
  
1、对于996的看法  
2、线程池的源码看过吗，能说说吗？
3、知道哪些锁的底层原理？（说了Sync）  
1. **悲观锁和乐观锁：**
    - 悲观锁和乐观锁是两种基本的并发控制策略。悲观锁的底层实现通常依赖于底层的硬件指令（例如，使用CAS指令）或使用操作系统提供的互斥锁（Mutex）。乐观锁通常使用版本号（版本戳）机制，在读取数据时获取版本号，更新数据时比较版本号，从而实现乐观地进行并发控制。
2. **ReentrantLock：**
    - `ReentrantLock` 是Java中的可重入锁，它的底层实现通常基于CAS（Compare and Swap）指令。CAS是一种乐观锁的实现方式，通过比较并交换操作来保证对共享资源的原子性操作。`ReentrantLock` 提供了可重入特性，同一个线程可以多次获取锁。
3. **synchronized：**
    - `synchronized` 是Java中最常用的锁机制，它的底层实现涉及到底层的对象头和monitor。Java对象头中包含了用于锁的信息，而monitor是一个底层的数据结构，用于管理锁的获取和释放。`synchronized` 使用了互斥锁来确保同一时刻只有一个线程可以进入临界区。
4. **ReadWriteLock：**
    - `ReadWriteLock` 接口的常见实现是 `ReentrantReadWriteLock`。它使用了两个锁，一个是读锁，一个是写锁。读锁的底层实现通常基于共享锁，写锁通常基于排他锁。这样可以实现多个线程同时读取共享资源，但只有一个线程能够写入。
5. **StampedLock：**
    - `StampedLock` 是Java 8 引入的一种读写锁。它的底层实现也基于CAS指令，但相比`ReentrantReadWriteLock` 更为灵活，提供了更多的功能，如乐观读锁、悲观读锁、写锁等。
6. **CAS（Compare and Swap）：**
    - CAS 是一种底层的原子操作，通常用于实现乐观锁。在多线程环境中，CAS操作可以确保只有当共享资源的当前值符合预期值时，才进行更新。Java中的 `Atomic` 类就是基于CAS实现的。
4、sync的四种状态？（从无锁到重量级锁）  
5、四种状态下哪些可以访问系统资源？（真不知道……）  
6、怎么了解AQS的？  
1. **同步状态（Sync State）：**
    - AQS 中的同步状态是一个整数，表示同步器的状态。不同的同步器可以定义不同的含义和使用方式。比如，对于ReentrantLock，同步状态表示持有锁的线程数。
2. **等待队列（Wait Queue）：**
    - AQS 使用一个FIFO的等待队列来管理竞争同步器的线程。等待队列中的线程会按照先进先出的顺序争夺同步器的访问权。
3. **获取锁和释放锁的模板方法：**
    - AQS 提供了两个主要的模板方法 `acquire` 和 `release`，供具体的同步器去实现。这两个方法定义了同步器的获取和释放的规范。
4. **Condition 对象：**
    - AQS 支持 Condition 对象，它提供了类似于 `Object.wait()` 和 `Object.notify()` 的功能。Condition 可以通过 `AQS.newCondition()` 方法创建，用于实现精细化的线程等待和唤醒。
5. **CAS（Compare and Swap）操作：**
    - AQS 使用CAS操作来进行原子性的状态更新。这是通过`Unsafe`类或`java.util.concurrent.atomic`包中的原子类来实现的。CAS是一种乐观锁的实现方式，避免了使用锁的代价。
6. **独占锁和共享锁：**
    - AQS 可以用于实现独占锁和共享锁。独占锁只允许一个线程持有，而共享锁允许多个线程同时持有。
7、volitile能锁住对象吗，作用是什么？  
8、几种垃圾回收的算法？  
9、常见的垃圾回收器？  
10、双亲委派机制？  
11、双亲委派的作用？  
12、B树和B+树的区别？  
13、B+树哪里用？  
14、一个表给a列加了索引，给了两个sql语句，一个是select * from xx ……. like “abc%”，还有一个是like “%abc”，哪个走了索引？  
15、分布式情况下，sync和reentrantlock这些锁能否锁住资源？（给我问懵了…然后给自己挖坑说分布式有分布式锁啊）  
16、分布式锁怎么实现？（说了redis）  
17、redis实现分布式锁的加锁和设置什么（忘了）是否是原子性操作，怎么保证原子性？  
18、好像是问redis分布式锁出现的问题是如何解决的？（没说上来，但给自己挖坑说用Redisson）  
加锁、设置过期时间、保证原子性（lua脚本），锁的自动续期：redisson，看门狗机制
19、细问redisson（直接说不是很了解）  
20、缓存穿透有哪些解决方案？  
21、懒汉和饿汉的区别？（真忘了…）  
22、单例模式会有线程安全问题吗？（回答了双重校验锁）  
23、遇到高并发的问题应当如何处理？（开始胡诌，面试官对答案好像也不是很满意）  
24、问怎么限流（回答用sentinel，但具体细节不会）  
25、怎么做高可用（具体的问题记不太清了）  
  
1. 说一下前缀树这种数据结构，查询的时间复杂度，查询的过程
2. 为什么用ES做搜索功能，为什么ES很快
3. Kafka异步双写什么意思
4. Java中HashMap和TreeMap由什么区别，时间复杂度
5. 为什么用红黑树实现，不用平衡二叉树
6. 什么是聚簇索引，什么是非聚簇索引

## 二面

1. 技术交流社区项目比较好的点
2. ES的数据一致性，Redis和MySQL的数据一致性
3. 怎么保证发送消息的顺序性（ES异步双写同步数据时，如果修改了两次怎么保证这两次的顺序性）
4. Spring的三级缓存
5. 什么是缓存穿透，怎么解决
6. 如果删除一条数据后，怎么解决，布隆过滤器怎么解决，可以删除吗

  