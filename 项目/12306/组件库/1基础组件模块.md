**1.定义全局配置常量和过滤器执行顺序。**
类似于用户信息这种多处使用的变量，分别定义肯定是不优雅的，找个地方将这个定义，并被用户和网关同时使用；还有**每个基础组件的执行顺序需要在全局定义**，便于扩展和解耦，不用在业务逻辑中考虑执行顺序问题

**2.封装 Spring 应用上下文 `ApplicationContextHolder`。**
很多时候，我们也需要在非 Spring Bean 中使用到 Spring Bean，依赖 Spring 提供的 **ApplicationContextAware**接口，来将 Spring IOC 容器的对象放到一个自定义容器中，并持有 Spring IOC 容器，提供获取bean的方法以便在其它地方获取bean而不采用注入方式
这种方式实际上是自定义了一个对spring容器的引用（单例模式），在创建之初就是指向spring容器，因此可以在全局的任意地方直接获取spring容器中的所有bean
但这种全局状态可能导致潜在的并发和线程安全问题，并且测试时也有困难；通过将容器的引用存储在静态变量中，可能会导致容器的引用在容器关闭后仍然存在，可能引发内存泄漏等问题。

**3.封装 FastJSON 安全模式，客户端可通过配置 `fastjson.safa-mode=true` 开启安全模式。**
开启后关闭类型隐式传递（结合ApplicationBaseAutoConfiguration自动装配）

**4.封装应用初始化事件，通过 Spring `ApplicationReadyEvent` 进行发布，并保证仅执行一次，`ApplicationInitializingEvent`。**
在实际应用开发中，会依赖很多应用初始化时执行任务
有些场景是依赖 Spring 容器初始化完成后调用的，`ContextRefreshedEvent` 这个时间就比较合适。但是它除了初始化调用，容器刷新也会调用。为了避免容器刷新造成二次调用初始化逻辑，需要对一些比较常用的事件简单封装一层逻辑
1）首先定义初始化事件对象类
2）其次，定义应用初始化后置处理器，防止 Spring 事件被多次执行（通过锁来保证同一时间只有一个事件进行初始化。初始化后设置一个标识，下次如果再触发，就不再执行，类似于幂等处理的逻辑。）

**5.单例对象容器，可避免重复创建对象，方便全局访问。**