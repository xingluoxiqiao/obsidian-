# 项目结构
## canal组件
订单关闭或取消后置处理组件
列车余票缓存更新组件
## 常量及枚举类
系统级公共常量：提前买票天数ADVANCE_TICKET_DAY = 15
RocketMQ 购票服务常量类：topic，tag，key
Redis Key 定义常量类
退款类型枚举
座位状态枚举
交通工具座位类型
车票状态枚举
交通工具类型
购票相关责任链 Mark 枚举：
	车票查询过滤器（三个实现）
	- 出发日期不能小于当前日期，出发地和目的地不能相同
	- 出发地不能为空，目的地不能为空，出发日期不能为空
	- 验证数据是否正确
	车票购买过滤器（四个实现）
	- 验证参数必填 列车标识 出发站点 到达站点 乘车人 座位类型
	- 验证列车站点库存是否充足（是否有余票）
	- 验证参数是否有效 车次车站
	- 验证乘客是否重复购买
	车票退款过滤器（一个实现）
	- 验证数据是否为空或空的字符串 订单号 退款类型 部分退款子订单记录集合
列车标签枚举
Canal 执行策略标记枚举
地区&站点类型枚举
购票来源
## 配置
Hippo4j 动态线程池配置：分配一个用户购买不同类型车票的线程池
## controller
## DAO
列车站点价格实体
车站实体
地区表
列车站点实体
列车实体
车票实体
车厢实体
列车站点关系实体
座位实体
## DTO
### domain
座位类型和座位数量实体
站点路线实体
动车实体
高铁座位基础信息
购票乘车人详情实体
车次集合实体
普通车实体
动车实体
席别类型实体
### req
车票分页查询请求参数
地区&站点查询请求入参
车票退款请求入参数实体
车票子订单查询
购票请求入参
取消车票订单请求入参
### resp
车票分页查询响应参数
车票购买返回参数
站点分页查询响应参数
车票订单详情返回参数
地区&站点分页查询响应参数
车票退款返回详情实体
列车站点查询响应参数
## 定时任务
抽象列车&车票相关定时任务
地区站点查询定时任务 
站点详细信息定时任务
## 消息队列
延迟关闭订单消费者
支付结果回调购票消费者
列车车票余量缓存更新消费端

消息体包装器

支付结果回调购票服务事件
延迟关闭订单事件
Canal Binlog 监听触发时间
## 远程调用
### dto
车票订单详情返回参数
车票订单创建请求参数
乘车人返回参数
车票订单详情创建请求参数
退款请求入参数实体
支付单详情信息返回参数
车票订单详情返回参数
退款详情返回参数实体
## Service
座位余量缓存加载
列车车票余量令牌桶购票时
列车座位选择器
### 工具类
日期工具类
座位转换工具类
匹配剩余的座位工具类
站点计算工具
座位统计工具类
座位号转换工具
自定义时间比较器





# 车站管理
## 查询车站，城市站点集合信息
## 根据列车ID查询站点信息
List\<TrainStationDO>

# 车票管理
## 根据条件查询车票
**总结：站点code--->站点间详细信息（列车实体）--->余票信息--->分页结果**
出发地、目的地、出发日期、出发站点、到达站点
V1：
1.责任链模式（车票查询过滤器） 验证城市名称是否存在、不存在加载缓存以及出发日期不能小于当前日期等等
2.从redis中获取起始站和终点站的信息（通过对应的code形成\[起始站，终点站]的map）
3.如果信息中存在空值，获取 Redisson 分布式锁并重新获取起始站和终点站的信息，并通过双重校验锁避免多个线程同时进入临界区，确保只有一个线程能够执行从数据库获取数据的逻辑，如果不使用双重校验锁，多个线程可能会同时检测到 Redis 中存在空值，导致多个线程同时去数据库请求数据，从而产生冗余的数据库请求。
4.从数据库中获取相关站点的全部数据，并更新缓存
5.构建列车详细信息hash表的key，并获取相关路线的全部信息
6.如果获取不到（信息中存在空值）获取 Redisson 分布式锁并重新获取起始站和终点站的信息，并通过双重校验锁查询数据库，获取列车站点关系，并基于此构建列车实体，同时根据起始站点和终点构建key，以列车实体作为value存入map
7.将上述map以hash形式存入数据库
8.将列车实体集合按出发时间顺序排序
9.查询列车余票信息，构建返回结果（TicketPageQueryRespDTO）
存在性能深渊问题：
1. 分布式锁的使用和缓存逻辑
2. 数据库操作频繁
3. Redis的频繁操作
4. 列车实体集合可能很大


v2:
v1的问题在于频繁进行分布式锁的获取和数据库的查询
v2进行了优化：
1.使用定时任务加载缓存，确保缓存中有值，避免了分布式锁和双重校验锁的使用
2.通过redis管道优化余票查询和价格查询，减少了redis的连接，加快了响应速度

## 车票购买
购票请求入参PurchaseTicketReqDTO--->列车实体TrainDO--->列车购票出参TrainPurchaseTicketRespDTO--->车票实体TicketDO--->车票订单详情创建请求参数TicketOrderItemCreateRemoteReqDTO--->车票订单详情返回参数 TicketOrderDetailRespDTO--->车票订单创建请求参数TicketOrderCreateRemoteReqDTO--->车票购买返回参数TicketPurchaseRespDTO
v1:
1.责任链验证参数
2.获取分布式锁
3.通过座位选择器分配座位
4.远程调用订单服务
5.锁定余票（更新余票）
6.返回购票结果
// v1 版本购票存在 4 个较为严重的问题
顺时高并发压垮系统  
先买票不一定有票(非公平锁)  
分布式锁压力（所有用户都去抢分布式锁）  
用户购票响应慢（不同座位类型的票在一起抢）

v2：
增加令牌容器，不是所有用户都抢分布式锁，先经过令牌容器过滤后再去
获取分布式锁时获取公平锁
动态线程池机制分类型购票
## 在线选座
座位选择器
1. **参数解析：**
    - 方法接收两个参数，`trainType` 表示列车类型，`requestParam` 是包含购票请求信息的对象，包括列车信息、出发站、到达站以及乘客详情等。
2. **乘客信息处理：**
    - 通过 `requestParam.getPassengers()` 获取乘客信息列表，并按照座位类型进行分组，使用 `Collectors.groupingBy`。
    - `seatTypeMap` 是一个 `Map`，键为座位类型，值为对应座位类型的乘客列表。
3. **并发处理不同座位类型的购票请求：**
    - 如果购票的座位类型大于1，表示有多种座位类型需要处理，采用并发处理的方式。
    - 使用线程池 `selectSeatThreadPoolExecutor` 处理不同座位类型的购票请求，每个座位类型的购票请求都是一个独立的任务。
    - 使用 `Future` 来异步获取每个座位类型购票请求的结果。
4. **购票请求处理：**
    - `distributeSeats` 方法负责实际的座位分配操作，返回一个购票结果列表。
    - 将每个座位类型的购票请求任务提交到线程池，获取 `Future` 对象，然后通过并行流获取每个购票请求的结果。
    - 将所有结果合并到 `actualResult` 中。
5. **单一座位类型处理：**
    - 如果购票的座位类型只有一种，直接调用 `distributeSeats` 方法处理。
6. **结果校验：**
    - 检查 `actualResult` 是否为空或与乘客详情数量不一致，如果不一致抛出异常，表示站点余票不足。
7. **查询乘客详细信息：**
    - 通过 `userRemoteService.listPassengerQueryByIds` 远程调用用户服务查询乘客详细信息。
    - 结果存储在 `passengerRemoteResultList` 中。
8. **为购票结果设置乘客详细信息和票价：**
    - 遍历 `actualResult`，通过乘客ID关联乘客详细信息，并通过列车价格表查询到相应座位的票价。
9. **更新列车中间站点余票：**
    - 调用 `seatService.lockSeat` 方法，锁定购票的座位，防止其他乘客购票时占用相同的座位。
10. **返回结果：**
	- 返回 `actualResult`，即购票结果列表。
其中distributeSeats是一个座位分配的具体实现方法，通过调用策略模式中的选择策略并执行的方式，根据列车类型和座位类型，为一组乘客分配座位
一等座，二等座，三等座分别继承自抽象高铁购票模板基础服务AbstractTrainPurchaseTicketTemplate，AbstractTrainPurchaseTicketTemplate实现抽象策略模式接口AbstractExecuteStrategy接口，程序启动时，自动将以上策略加入map容器中，后续通过mark获取并使用
## 多人邻座查询

## 创建车票订单

## 退还用户付款
## 车票信息回滚
## 订单状态反转
# 初始化定时任务
## 地区站点查询
## 站点详细信息查询
## 列车路线信息
## 列车站点余票


