## 设计模式
设计模式组件库（index12306-designpattern-spring-boot-starter）中封装了策略、责任链、构建者等多种设计模式，在项目中多处使用。例如：
1. **策略模式**：用户购票时根据不同座位类型（一等、二等、商务）自动分配对应的选座策略，体现了策略模式。策略模式允许定义一系列算法，将它们封装成独立的策略类，并使得这些策略类可以互相替换，从而使得客户端可以独立于具体的算法变化。这种设计带来了高度的代码复用和可维护性，因为每个座位类型都有自己独立的实现，当需要添加新的座位类型或者调整分配逻辑时，只需增加或修改相应的策略类，而不会影响到其他部分的代码。这实现了座位分配的灵活性和可扩展性，使得系统更容易应对未来的变化和需求，同时也提高了代码的清晰度和可读性。
2. **责任链模式**：当一个用户发起请求时，顺利的话请求会经过所有拦截器，最终到达业务代码逻辑；或者也可以实现不满足某种条件时被打回，不进行业务逻辑处理，项目中对用户信息的校验，车票信息的校验等多处都采用了这种模式。在责任链模式中，多个处理器（参照上述拦截器）依次处理同一个请求。一个请求先经过 A 处理器处理，然后再把请求传递给 B 处理器，B 处理器处理完后再传递给 C 处理器，以此类推，形成一个链条，链条上的每个处理器各自承担各自的处理职责。
3. **构建者模式**：对实体对象的封装采用了构建者模式，这种设计模式使得对象的构建过程更加灵活和可读。通过构建者模式，可以通过链式调用的方式设置对象的属性，而不必依赖多个构造函数。这提高了代码的可维护性，同时允许逐步构建对象，避免了过多的构造器参数。构建者模式为实体对象的创建提供了一种优雅而清晰的解决方案，使得项目中的各种对象的构建过程更加简洁、可扩展。

# redis相关
1.封装缓存组件库
2.分布式锁redisson
3.布隆过滤器redisson
4.lua脚本保证原子性
# 数据库相关
1.shardingSphere
2.分库分表
3.复合分片算法

# rocketMQ
消息幂等
# 业务相关
令牌限流

# 其它相关
缓存一致性
分布式架构
