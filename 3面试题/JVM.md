# JDK ,JRE ,JVM
# Java文件的编译和运行流程
.java   .class   二进制
	Javac    JVM
# JVM 运行时数据区
方法区  所有线程共享，存储类信息、常量，静态变量，即时编译后的代码
java堆（GC堆）所有线程共享（可分配线程私有缓冲区）存放对象实例 分为新生代老生代 物理可以不连续
程序计数器 保存当前线程所正在执行的字节码指令的地址（帮当前线程记住它在干嘛） 线程私有
虚拟机栈 线程私有，生命周期和线程一样 
              存储java方法产生的栈帧（存储局部变量表（指向堆中地址）、操作数表、动态链接（方法调用产生的链接）、方法出口（正常return或异常））
本地方法栈 java源码中的方法栈，native关键字
# java内存结构（包含JVM运行时数据区）
![[Pasted image 20231205152426.png]]
## 直接内存（Direct Memory）
直接内存不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域。但是既然是内存，肯定还是受本机总内存（包括RAM以及SWAP区或者分页文件）大小以及处理器寻址空间的限制。
在JDK1.4 中新加入了NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区（Buffer）的I/O 方式，它可以使用native 函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native（本地）堆中来回复制数据。
直接内存申请空间耗费很高的性能，堆内存申请空间耗费比较低  
直接内存的IO读写的性能要优于堆内存，在多次读写操作的情况相差非常明显
## JVM字节码执行引擎
虚拟机核心的组件就是执行引擎，它负责执行虚拟机的字节码，一般户先进行编译成机器码后执行。
“虚拟机”是一个相对于“物理机”的概念，虚拟机的字节码是不能直接在物理机上运行的，需要JVM字节码执行引擎编译成机器码后才可在物理机上执行。
## 垃圾收集系统
程序在运行过程中，会产生大量的内存垃圾（一些没有引用指向的内存对象都属于内存垃圾，因为这些对象已经无法访问，程序用不了它们了，对程序而言它们已经死亡），为了确保程序运行时的性能，java虚拟机在程序运行的过程中不断地进行自动的垃圾回收（GC）。
# 垃圾回收（GC）
新生代、老年代、永生代
eden、From Survivor、To Survivor
Minor GC、Major GC、Full GC
对象在各生代间的晋升和GC触发条件
判断对象是否存活的方法：引用计数法、可达性分析法
# 垃圾回收机制策略（GC算法）
引用计数
标记清除  内存碎片 STW
标记整理  更新引用
复制         内存浪费
# 垃圾收集器
Serial 单线程        ParNew（Serial多线程）   Parallel Scavenge
SerialOld（MSC）CMS                                  Paraller Old
G1
# 类加载流程
加载  流程
连接 验证，准备，解析
初始化
## 类加载器
## 双亲委派
[一篇文章掌握整个JVM，JVM超详细解析！！！-CSDN博客](https://blog.csdn.net/weixin_43122090/article/details/105093777?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170175401816800227488967%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170175401816800227488967&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-105093777-null-null.142^v96^pc_search_result_base3&utm_term=jvm&spm=1018.2226.3001.4187)