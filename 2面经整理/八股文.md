# 集合
### 3.1 Java常见的集合类

>**面试官**：说一说Java提供的常见集合？（画一下集合结构图）
>
>**候选人**：
>
>在java中提供了量大类的集合框架，主要分为两类：
>
>第一个是Collection  属于单列集合，第二个是Map  属于双列集合
>
>- 在Collection中有两个子接口List和Set。在我们平常开发的过程中用的比较多像list接口中的实现类ArrarList和LinkedList。  在Set接口中有实现类HashSet和TreeSet。
>- 在map接口中有很多的实现类，平时比较常见的是HashMap、TreeMap，还有一个线程安全的map:ConcurrentHashMap

### 3.2 List

>**面试官**：ArrayList底层是如何实现的？
>
>**候选人**：
>
>嗯~，我阅读过arraylist的源码，我主要说一下add方法吧
>
>第一：确保数组已使用长度（size）加1之后足够存下下一个数据 
>
>第二：计算数组的容量，如果当前数组已使用长度+1后的大于当前的数组长度，则调用grow方法扩容（原来的1.5倍）
>
>第三：确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上。 
>
>第四：返回添加成功布尔值。 
>
>**面试官**：ArrayList list=new ArrayList(10)中的list扩容几次
>
>**候选人**：
>
>​	是new了一个ArrarList并且给了一个构造参数10，对吧？(问题一定要问清楚再答)
>
>**面试官**：是的
>
>**候选人**：
>
>​    好的，在ArrayList的源码中提供了一个带参数的构造方法，这个参数就是指定的集合初始长度，所以给了一个10的参数，就是指定了集合的初始长度是10，这里面并没有扩容。
>
>-------------------------------------------
>
>**面试官**：如何实现数组和List之间的转换
>
>**候选人**：
>
>​	嗯，这个在我们平时开发很常见
>
>​    数组转list，可以使用jdk自动的一个工具类Arrars，里面有一个asList方法可以转换为数组
>
>​    List 转数组，可以直接调用list中的toArray方法，需要给一个参数，指定数组的类型，需要指定数组的长度。
>
>**面试官**：用Arrays.asList转List后，如果修改了数组内容，list受影响吗？List用toArray转数组后，如果修改了List内容，数组受影响吗
>
>**候选人**：
>
>Arrays.asList转换list之后，如果修改了数组的内容，list会受影响，因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是同一个内存地址
>
>list用了toArray转数组后，如果修改了list内容，数组不会影响，当调用了toArray以后，在底层是它是进行了数组的拷贝，跟原来的元素就没啥关系了，所以即使list修改了以后，数组也不受影响
>
>-----
>
>**面试官**：ArrayList 和 LinkedList 的区别是什么？
>
>**候选人**：
>
>嗯，它们两个主要是底层使用的数据结构不一样，ArrayList 是动态数组，LinkedList 是双向链表，这也导致了它们很多不同的特点。
>
>1，从操作数据效率来说
>
>ArrayList按照下标查询的时间复杂度O(1)【内存是连续的，根据寻址公式】， LinkedList不支持下标查询
>
>查找（未知索引）： ArrayList需要遍历，链表也需要链表，时间复杂度都是O(n)
>
>新增和删除
>
>- ArrayList尾部插入和删除，时间复杂度是O(1)；其他部分增删需要挪动数组，时间复杂度是O(n)
>- LinkedList头尾节点增删时间复杂度是O(1)，其他都需要遍历链表，时间复杂度是O(n)
>
>2，从内存空间占用来说
>
>ArrayList底层是数组，内存连续，节省内存
>
>LinkedList 是双向链表需要存储数据，和两个指针，更占用内存
>
>3，从线程安全来说，ArrayList和LinkedList都不是线程安全的
>
>**面试官**：嗯，好的，刚才你说了ArrayList 和 LinkedList 不是线程安全的，你们在项目中是如何解决这个的线程安全问题的？
>
>**候选人**：
>
>嗯，是这样的，主要有两种解决方案：
>
>第一：我们使用这个集合，优先在方法内使用，定义为局部变量，这样的话，就不会出现线程安全问题。
>
>第二：如果非要在成员变量中使用的话，可以使用线程安全的集合来替代
>
>ArrayList可以通过Collections 的 synchronizedList 方法将 ArrayList 转换成线程安全的容器后再使用。
>
>LinkedList 换成ConcurrentLinkedQueue来使用

### 3.4 HashMap

>**面试官**：说一下HashMap的实现原理？
>
>**候选人**：
>
>​	嗯。它主要分为了一下几个部分：
>
>1，底层使用hash表数据结构，即数组+（链表 | 红黑树）
>
>2，添加数据时，计算key的值确定元素在数组中的下标
>
>​	key相同则替换
>
>​	不同则存入链表或红黑树中
>
>3，获取数据通过key的hash计算数组下标获取元素
>
>**面试官**：HashMap的jdk1.7和jdk1.8有什么区别
>
>**候选人**：
>
>- JDK1.8之前采用的拉链法，数组+链表
>
>- JDK1.8之后采用数组+链表+红黑树，链表长度大于8且数组长度大于64则会从链表转化为红黑树
>
>**面试官**：好的，你能说下HashMap的put方法的具体流程吗？
>
>**候选人**：
>
>嗯好的。
>
>1. 判断键值对数组table是否为空或为null，否则执行resize()进行扩容（初始化）
>
>2. 根据键值key计算hash值得到数组索引
>
>3. 判断table[i]==null，条件成立，直接新建节点添加
>
>4. 如果table[i]==null ,不成立
>
>   4.1 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value
>
>   4.2 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对
>
>   4.3 遍历table[i]，链表的尾部插入数据，然后判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操 作，遍历过程中若发现key已经存在直接覆盖value
>
>5. 插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold（数组长度*0.75），如果超过，进行扩容。
>
>**面试官**：好的，刚才你多次介绍了hsahmap的扩容，能讲一讲HashMap的扩容机制吗？
>
>**候选人**：
>
>好的
>
>- 在添加元素或初始化的时候需要调用resize方法进行扩容，第一次添加数据初始化数组长度为16，以后每次每次扩容都是达到了扩容阈值（数组长度 * 0.75）
>
>- 每次扩容的时候，都是扩容之前容量的2倍； 
>
>- 扩容之后，会新创建一个数组，需要把老数组中的数据挪动到新的数组中
>  - 没有hash冲突的节点，则直接使用 e.hash & (newCap - 1) 计算新数组的索引位置
>  - 如果是红黑树，走红黑树的添加
>  - 如果是链表，则需要遍历链表，可能需要拆分链表，判断(e.hash & oldCap)是否为0，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上
>
>**面试官**：好的，刚才你说的通过hash计算后找到数组的下标，是如何找到的呢，你了解hashMap的寻址算法吗？
>
>**候选人**：
>
>这个哈希方法首先计算出key的hashCode值，然后通过这个hash值右移16位后的二进制进行按位**异或运算**得到最后的hash值。
>
>在putValue的方法中，计算数组下标的时候使用hash值与数组长度取模得到存储数据下标的位置，hashmap为了性能更好，并没有直接采用取模的方式，而是使用了数组长度-1 得到一个值，用这个值按位与运算hash值，最终得到数组的位置。
>
>**面试官**：为何HashMap的数组长度一定是2的次幂？
>
>**候选人**：
>
>嗯，好的。hashmap这么设计主要有两个原因：
>
>第一：
>
>计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模
>
>第二：
>
>扩容时重新计算索引效率更高：在进行扩容是会进行判断 hash值按位与运算旧数组长租是否 == 0 
>
>如果等于0，则把元素留在原来位置 ，否则新位置是等于旧位置的下标+旧数组长度
>
>
>
>**面试官**：好的，我看你对hashmap了解的挺深入的，你知道hashmap在1.7情况下的多线程死循环问题吗？
>
>**候选人**：
>
>嗯，知道的。是这样
>
>jdk7的的数据结构是：数组+链表
>
>在数组进行扩容的时候，因为链表是**头插法**，在进行数据迁移的过程中，有可能导致死循环
>
>比如说，现在有两个线程
>
>线程一：**读取**到当前的hashmap数据，数据中一个链表，在准备扩容时，线程二介入
>
>线程二也读取hashmap，直接进行扩容。因为是头插法，链表的顺序会进行颠倒过来。比如原来的顺序是AB，扩容后的顺序是BA，线程二执行结束。
>
>当线程一再继续执行的时候就会出现死循环的问题。
>
>线程一先将A移入新的链表，再将B插入到链头，由于另外一个线程的原因，B的next指向了A，所以B->A->B,形成循环。
>
>当然，JDK 8 将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），**尾插法**，就避免了jdk7中死循环的问题。
>
>**面试官**：好的，hashmap是线程安全的吗？
>
>**候选人**：不是线程安全的
>
>**面试官**：那我们想要使用线程安全的map该怎么做呢？
>
>**候选人**：我们可以采用ConcurrentHashMap进行使用，它是一个线程安全的HashMap
>
>**面试官**：那你能聊一下ConcurrentHashMap的原理吗？
>
>**候选人**：好的，请参考《多线程相关面试题》中的ConcurrentHashMap部分的讲解
>
>-----
>
>**面试官**：HashSet与HashMap的区别？
>
>**候选人**：嗯，是这样。
>
>HashSet底层其实是用HashMap实现存储的, HashSet封装了一系列HashMap的方法. 依靠HashMap来存储元素值,(利用hashMap的key键进行存储), 而value值默认为Object对象. 所以HashSet也不允许出现重复值, 判断标准和HashMap判断标准相同, 两个元素的hashCode相等并且通过equals()方法返回true.
>
>**面试官**：HashTable与HashMap的区别
>
>**候选人**：
>
>嗯，他们的主要区别是有几个吧
>
>第一，数据结构不一样，hashtable是数组+链表，hashmap在1.8之后改为了数组+链表+红黑树
>
>第二，hashtable存储数据的时候都不能为null，而hashmap是可以的
>
>第三，hash算法不同，hashtable是用本地修饰的hashcode值，而hashmap经常了二次hash
>
>第四，扩容方式不同，hashtable是当前容量翻倍+1，hashmap是当前容量翻倍
>
>第五，hashtable是线程安全的，操作数据的时候加了锁synchronized，hashmap不是线程安全的，效率更高一些
>
>在实际开中不建议使用HashTable，在多线程环境下可以使用ConcurrentHashMap类

# 多线程
### 6.1 线程的基础知识

>**面试官**：聊一下并行和并发有什么区别？
>
>**候选人：**
>
>是这样的~~
>
>现在都是多核CPU，在多核CPU下
>
>并发是同一时间应对多件事情的能力，多个线程轮流使用一个或多个CPU
>
>并行是同一时间动手做多件事情的能力，4核CPU同时执行4个线程
>
>------
>
>**面试官**：说一下线程和进程的区别？
>
>**候选人：**
>
>嗯，好~
>
>- 进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务
>- 不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间
>- 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低(上下文切换指的是从一个线程切换到另一个线程)
>
>----
>
>**面试官**：如果在java中创建线程有哪些方式？
>
>**候选人：**
>
>在java中一共有四种常见的创建方式，分别是：继承Thread类、实现runnable接口、实现Callable接口、线程池创建线程。通常情况下，我们项目中都会采用线程池的方式创建线程。
>
>**面试官**：好的，刚才你说的runnable 和 callable 两个接口创建线程有什么不同呢？
>
>**候选人：**
>
>是这样的~
>
>最主要的两个线程一个是有返回值，一个是没有返回值的。
>
>Runnable 接口run方法无返回值；Callable接口call方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果
>
>还有一个就是，他们异常处理也不一样。Runnable接口run方法只能抛出运行时异常，也无法捕获处理；Callable接口call方法允许抛出异常，可以获取异常信息
>
>在实际开发中，如果需要拿到执行的结果，需要使用Callalbe接口创建线程，调用FutureTask.get()得到可以得到返回值，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。
>
>------
>
>**面试官**：线程包括哪些状态，状态之间是如何变化的？
>
>**候选人：**
>
>在JDK中的Thread类中的枚举State里面定义了6中线程的状态分别是：新建、可运行、终结、阻塞、等待和有时限等待六种。
>
>关于线程的状态切换情况比较多。我分别介绍一下
>
>当一个线程对象被创建，但还未调用 start 方法时处于**新建**状态，调用了 start 方法，就会由**新建**进入**可运行**状态。如果线程内代码已经执行完毕，由**可运行**进入**终结**状态。当然这些是一个线程正常执行情况。
>
>如果线程获取锁失败后，由**可运行**进入 Monitor 的阻塞队列**阻塞**，只有当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的**阻塞**线程，唤醒后的线程进入**可运行**状态
>
>如果线程获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从**可运行**状态释放锁**等待**状态，当其它持锁线程调用 notify() 或 notifyAll() 方法，会恢复为**可运行**状态
>
>还有一种情况是调用 sleep(long) 方法也会从**可运行**状态进入**有时限等待**状态，不需要主动唤醒，超时时间到自然恢复为**可运行**状态
>
>**面试官**：嗯，好的，刚才你说的线程中的 wait 和 sleep方法有什么不同呢？
>
>**候选人：**
>
>它们两个的相同点是都可以让当前线程暂时放弃 CPU 的使用权，进入阻塞状态。
>
>不同点主要有三个方面：
>
>第一：方法归属不同
>
>sleep(long) 是 Thread 的静态方法。而 wait()，是 Object 的成员方法，每个对象都有
>
>第二：线程醒来时机不同
>
>线程执行 sleep(long) 会在等待相应毫秒后醒来，而 wait() 需要被 notify 唤醒，wait() 如果不唤醒就一直等下去
>
>第三：锁特性不同
>
>wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制
>
>wait 方法执行后会释放对象锁，允许其它线程获得该对象锁（相当于我放弃 cpu，但你们还可以用）
>
>而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（相当于我放弃 cpu，你们也用不了）
>
>**面试官**：好的，我现在举一个场景，你来分析一下怎么做，新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？
>
>**候选人：**
>
>嗯，我思考一下 （适当的思考或想一下属于正常情况，脱口而出反而太假[背诵痕迹]）
>
>可以这么做，在多线程中有多种方法让线程按特定顺序执行，可以用线程类的**join**()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。
>
>比如说：
>
>使用join方法，T3调用T2，T2调用T1，这样就能确保T1就会先完成而T3最后完成
>
>**面试官**：在我们使用线程的过程中，有两个方法。线程的 run()和 start()有什么区别？
>
>**候选人：**
>
>start方法用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。start方法只能被调用一次。run方法封装了要被线程执行的代码，可以被调用多次。
>
>**面试官**：那如何停止一个正在运行的线程呢？
>
>**候选人**：
>
>有三种方式可以停止线程
>
>第一：可以使用退出标志，使线程正常退出，也就是当run方法完成后线程终止，一般我们加一个标记
>
>第二：可以使用线程的stop方法强行终止，不过一般不推荐，这个方法已作废
>
>第三：可以使用线程的interrupt方法中断线程，内部其实也是使用中断标志来中断线程
>
>我们项目中使用的话，建议使用第一种或第三种方式中断线程

### 6.2 线程中并发锁

>**面试官**：讲一下synchronized关键字的底层原理？
>
>**候选人**：
>
>synchronized 底层使用的JVM级别中的Monitor 来决定当前线程是否获得了锁，如果某一个线程获得了锁，在没有释放锁之前，其他线程是不能或得到锁的。synchronized 属于悲观锁。
>
>synchronized 因为需要依赖于JVM级别的Monitor ，相对性能也比较低。
>
>**面试官**：好的，你能具体说下Monitor 吗？
>
>**候选人**：
>
>monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因
>
>monitor内部维护了三个变量
>
>- WaitSet：保存处于Waiting状态的线程
>
>- EntryList：保存处于Blocked状态的线程
>
>- Owner：持有锁的线程
>
>只有一个线程获取到的标志就是在monitor中设置成功了Owner，一个monitor中只能有一个Owner
>
>在上锁的过程中，如果有其他线程也来抢锁，则进入EntryList 进行阻塞，当获得锁的线程执行完了，释放了锁，就会唤醒EntryList 中等待的线程竞争锁，竞争的时候是非公平的。
>
>**面试官**：好的，那关于synchronized 的锁升级的情况了解吗？
>
>**候选人**：
>
>嗯，知道一些（要谦虚）
>
>Java中的synchronized有偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。
>
>重量级锁：底层使用的Monitor实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低。
>
>轻量级锁：线程加锁的时间是错开的（也就是没有竞争），可以使用轻量级锁来优化。轻量级修改了对象头的锁标志，相对重量级锁性能提升很多。每次修改都是CAS操作，保证原子性
>
>偏向锁：一段很长的时间内都只被一个线程使用锁，可以使用了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只需要判断mark word中是否是自己的线程id即可，而不是开销相对较大的CAS命令
>
>一旦锁发生了竞争，都会升级为重量级锁
>
>**面试官**：好的，刚才你说了synchronized它在高并发量的情况下，性能不高，在项目该如何控制使用锁呢？
>
>**候选人**：
>
>嗯，其实，在高并发下，我们可以采用ReentrantLock来加锁。
>
>**面试官**：嗯，那你说下ReentrantLock的使用方式和底层原理？
>
>**候选人**：
>
>好的，
>
>ReentrantLock是一个可重入锁:，调用 lock 方 法获取了锁之后，再次调用 lock，是不会再阻塞，内部直接增加重入次数 就行了，标识这个线程已经重复获取一把锁而不需要等待锁的释放。
>
>ReentrantLock是属于juc报下的类，属于api层面的锁，跟synchronized一样，都是悲观锁。通过lock()用来获取锁，unlock()释放锁。
>
>它的底层实现原理主要利用**CAS+AQS队列**来实现。它支持公平锁和非公平锁，两者的实现类似
>
>构造方法接受一个可选的公平参数（**默认非公平锁**），当设置为true时，表示公平锁，否则为非公平锁。公平锁的效率往往没有非公平锁的效率高。
>
>**面试官**：好的，刚才你说了CAS和AQS，你能介绍一下吗？
>
>**候选人**：
>
>好的。
>
>CAS的全称是： Compare And Swap(比较再交换);它体现的一种乐观锁的思想，在无锁状态下保证线程操作数据的原子性。
>
>- CAS使用到的地方很多：AQS框架、AtomicXXX类
>
>- 在操作共享变量的时候使用的自旋锁，效率上更高一些
>
>- CAS的底层是调用的Unsafe类中的方法，都是操作系统提供的，其他语言实现
>
>
>
>AQS的话，其实就一个jdk提供的类AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架。
>
>内部有一个属性 state 属性来表示资源的状态，默认state等于0，表示没有获取锁，state等于1的时候才标明获取到了锁。通过cas 机制设置 state 状态
>
>在它的内部还提供了基于 FIFO 的等待队列，是一个双向列表，其中
>
>- tail 指向队列最后一个元素
>
>- head  指向队列中最久的一个元素
>
>其中我们刚刚聊的ReentrantLock底层的实现就是一个AQS。
>
>**面试官**：synchronized和Lock有什么区别 ? 	
>
>**候选人**：
>
  主要有三个方面不太一样
>
>第一，语法层面
>
>* synchronized 是关键字，源码在 jvm 中，用 c++ 语言实现，退出同步代码块锁会自动释放
>* Lock 是接口，源码由 jdk 提供，用 java 语言实现，需要手动调用 unlock 方法释放锁
>
>第二，功能层面
>
>* 二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能
>* Lock 提供了许多 synchronized 不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量，同时Lock 可以实现不同的场景，如 ReentrantLock， ReentrantReadWriteLock
>
>第三，性能层面
>
>* 在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖
>* 在竞争激烈时，Lock 的实现通常会提供更好的性能
>
>统合来看，需要根据不同的场景来选择不同的锁的使用。
>
>-----
>
>**面试官**：死锁产生的条件是什么？
>
>**候选人**：
>
>嗯，是这样的，一个线程需要同时获取多把锁，这时就容易发生死锁，举个例子来说：
>
>t1 线程获得A对象锁，接下来想获取B对象的锁
>
>t2 线程获得B对象锁，接下来想获取A对象的锁 
>
>这个时候t1线程和t2线程都在互相等待对方的锁，就产生了死锁
>
>**面试官**：那如果产出了这样的，如何进行死锁诊断？
>
>**候选人**：
>
>这个也很容易，我们只需要通过jdk自动的工具就能搞定
>
>我们可以先通过jps来查看当前java程序运行的进程id
>
>然后通过jstack来查看这个进程id，就能展示出来死锁的问题，并且，可以定位代码的具体行号范围，我们再去找到对应的代码进行排查就行了。
>
>-------
>
>**面试官**：请谈谈你对 volatile 的理解
>
>**候选人**：
>
>volatile 是一个关键字，可以修饰类的成员变量、类的静态成员变量，主要有两个功能
>
>第一：保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的,volatile关键字会强制将修改的值立即写入主存。
>
>第二： 禁止进行指令重排序，可以保证代码执行有序性。底层实现原理是，添加了一个**内存屏障**，通过插入内存屏障禁止在内存屏障**前后**的指令执行重排序优化
>
>--------
>
>**本文作者**：接《集合相关面试题》
>
>**面试官**：那你能聊一下ConcurrentHashMap的原理吗？
>
>**候选人**：
>
>嗯好的，
>
>ConcurrentHashMap 是一种线程安全的高效Map集合，jdk1.7和1.8也做了很多调整。
>
>- JDK1.7的底层采用是**分段的数组**+**链表** 实现
>- JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。
>
>在jdk1.7中 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一 种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构 的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修 改时，必须首先获得对应的 Segment的锁。
>
>Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元 素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁
>
>在jdk1.8中的ConcurrentHashMap 做了较大的优化，性能提升了不少。首先是它的数据结构与jdk1.8的hashMap数据结构完全一致。其次是放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保 证并发安全进行实现，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲 突，就不会产生并发 , 效率得到提升

### 6.3 线程池

>**面试官**：线程池的种类有哪些？
>
>**候选人**：
>
>嗯！是这样
>
>在jdk中默认提供了4中方式创建线程池
>
>第一个是：newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回 收空闲线程，若无可回收，则新建线程。 
>
>第二个是：newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列 中等待。 
>
>第三个是：newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。 
>
>第四个是：newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任 务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。
>
>**面试官**：线程池的核心参数有哪些？
>
>**候选人**：
>
>在线程池中一共有7个核心参数：
>
>1. corePoolSize 核心线程数目 - 池中会保留的最多线程数
>
>2. maximumPoolSize 最大线程数目 - 核心线程+救急线程的最大数目
>
>3. keepAliveTime 生存时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放
>
>4. unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等
>
>5. workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务
>
>6. threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等
>
>7. handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略
>
>   在拒绝策略中又有4中拒绝策略
>
>   当线程数过多以后，第一种是抛异常、第二种是由调用者执行任务、第三是丢弃当前的任务，第四是丢弃最早排队任务。默认是直接抛异常。
>
>**面试官**：如何确定核心线程池呢？
>
>**候选人**：
>
>是这样的，我们公司当时有一些规范，为了减少线程上下文的切换，要根据当时部署的服务器的CPU核数来决定，我们规则是：CPU核数+1就是最终的核心线程数。
>
>**面试官**：线程池的执行原理知道吗？
>
>**候选人**：
>
>嗯~，它是这样的
>
>首先判断线程池里的核心线程是否都在执行任务，如果不是则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队 列里。如果工作队列满了，则判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任 务。如果已经满了，则交给拒绝策略来处理这个任务。
>
>**面试官**：为什么不建议使用Executors创建线程池呢？
>
>**候选人**：
>
>好的，其实这个事情在阿里提供的最新开发手册《Java开发手册-嵩山版》中也提到了
>
>主要原因是如果使用Executors创建线程池的话，它允许的请求队列默认长度是Integer.MAX_VALUE，这样的话，有可能导致堆积大量的请求，从而导致OOM（内存溢出）。
>
>所以，我们一般推荐使用ThreadPoolExecutor来创建线程池，这样可以明确规定线程池的参数，避免资源的耗尽。

### 6.4 线程使用场景问题

>**面试官**：如果控制某一个方法允许并发访问线程的数量？
>
>**候选人**：
>在jdk中提供了一个Semaphore[seməfɔːr]类（信号量）
>
>它提供了两个方法，semaphore.acquire() 请求信号量，可以限制线程的个数，是一个正数，如果信号量是-1,就代表已经用完了信号量，其他线程需要阻塞了
>
>第二个方法是semaphore.release()，代表是释放一个信号量，此时信号量的个数+1
>
>
>
>**面试官**：好的，那该如何保证Java程序在多线程的情况下执行安全呢？
>
>**候选人**：
>
>嗯，刚才讲过了导致线程安全的原因，如果解决的话，jdk中也提供了很多的类帮助我们解决多线程安全的问题，比如：
>
>- JDK Atomic开头的原子类、synchronized、LOCK，可以解决原子性问题
>- synchronized、volatile、LOCK，可以解决可见性问题
>- Happens-Before 规则可以解决有序性问题
>
>---
>
>**面试官**：你在项目中哪里用了多线程？
>
>**候选人**：
>
 我想一下当时的场景\[根据自己简历上的模块设计多线程场景]
>
>参考场景一：
>
>es数据批量导入
>
>在我们项目上线之前，我们需要把数据量的数据一次性的同步到es索引库中，但是当时的数据好像是1000万左右，一次性读取数据肯定不行（oom异常），如果分批执行的话，耗时也太久了。所以，当时我就想到可以使用线程池的方式导入，利用CountDownLatch+Future来控制，就能大大提升导入的时间。
>
>参考场景二：
>
>在我做那个xx电商网站的时候，里面有一个数据汇总的功能，在用户下单之后需要查询订单信息，也需要获得订单中的商品详细信息（可能是多个），还需要查看物流发货信息。因为它们三个对应的分别三个微服务，如果一个一个的操作的话，互相等待的时间比较长。所以，我当时就想到可以使用线程池，让多个线程同时处理，最终再汇总结果就可以了，当然里面需要用到Future来获取每个线程执行之后的结果才行
>
>参考场景三：
>
>《黑马头条》项目中使用的
>
>我当时做了一个文章搜索的功能，用户输入关键字要搜索文章，同时需要保存用户的搜索记录（搜索历史），这块我设计的时候，为了不影响用户的正常搜索，我们采用的异步的方式进行保存的，为了提升性能，我们加入了线程池，也就说在调用异步方法的时候，直接从线程池中获取线程使用

### 6.5 其他

>**面试官**：谈谈你对ThreadLocal的理解
>
>**候选人**：
>
>嗯，是这样的~~
>
>ThreadLocal 主要功能有两个，第一个是可以实现资源对象的线程隔离，让每个线程各用各的资源对象，避免争用引发的线程安全问题，第二个是实现了线程内的资源共享
>
>**面试官**：好的，那你知道ThreadLocal的底层原理实现吗？
>
>**候选人**：
>
>在ThreadLocal内部维护了一个一个 ThreadLocalMap 类型的成员变量，用来存储资源对象
>
>当我们调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中
>
>当调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值
>
>当调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值
>
>**面试官**：好的，那关于ThreadLocal会导致内存溢出这个事情，了解吗？
>
>**候选人**：
>
>嗯，我之前看过源码，我想一下~~
>
>是应为ThreadLocalMap 中的 key 被设计为弱引用，它是被动的被GC调用释放key，不过关键的是只有key可以得到内存释放，而value不会，因为value是一个强引用。
>
>在使用ThreadLocal 时都把它作为静态变量（即强引用），因此无法被动依靠 GC 回收，建议主动的remove 释放 key，这样就能避免内存溢出。

# JVM 
### 5.1 JVM组成

>**面试官**：JVM由那些部分组成，运行流程是什么？
>
>**候选人:**
>
>嗯，好的~~
>
>在JVM中共有四大部分，分别是ClassLoader（类加载器）、Runtime Data Area（运行时数据区，内存分区）、Execution Engine（执行引擎）、Native Method Library（本地库接口）
>
>它们的运行流程是：
>
>第一，类加载器（ClassLoader）把Java代码转换为字节码
>
>第二，运行时数据区（Runtime Data Area）把字节码加载到内存中，而字节码文件只是JVM的一套指令集规范，并不能直接交给底层系统去执行，而是有执行引擎运行
>
>第三，执行引擎（Execution Engine）将字节码翻译为底层系统指令，再交由CPU执行去执行，此时需要调用其他语言的本地库接口（Native Method Library）来实现整个程序的功能。
>
>**面试官**：好的，你能详细说一下 JVM 运行时数据区吗？
>
>**候选人:**
>
>嗯，好~
>
>运行时数据区包含了堆、方法区、栈、本地方法栈、程序计数器这几部分，每个功能作用不一样。
>
>- 堆解决的是对象实例存储的问题，垃圾回收器管理的主要区域。
>- 方法区可以认为是堆的一部分，用于存储已被虚拟机加载的信息，常量、静态变量、即时编译器编译后的代码。
>- 栈解决的是程序运行的问题，栈里面存的是栈帧，栈帧里面存的是局部变量表、操作数栈、动态链接、方法出口等信息。
>- 本地方法栈与栈功能相同，本地方法栈执行的是本地方法，一个Java调用非Java代码的接口。
>- 程序计数器（PC寄存器）程序计数器中存放的是当前线程所执行的字节码的行数。JVM工作时就是通过改变这个计数器的值来选取下一个需要执行的字节码指令。
>
>**面试官**：好的，你再详细介绍一下程序计数器的作用？
>
>**候选人:**
>
>嗯，是这样~~
>
>java虚拟机对于多线程是通过线程轮流切换并且分配线程执行时间。在任何的一个时间点上，一个处理器只会处理执行一个线程，如果当前被执行的这个线程它所分配的执行时间用完了【挂起】。处理器会切换到另外的一个线程上来进行执行。并且这个线程的执行时间用完了，接着处理器就会又来执行被挂起的这个线程。这时候程序计数器就起到了关键作用，程序计数器在来回切换的线程中记录他上一次执行的行号，然后接着继续向下执行。
>
>**面试官**：你能给我详细的介绍Java堆吗?
>
>**候选人:**
>
>好的~
>
>Java中的堆术语线程共享的区域。主要用来保存**对象实例，数组**等，当堆中没有内存空间可分配给实例，也无法再扩展时，则抛出OutOfMemoryError异常。
>
>​	在JAVA8中堆内会存在年轻代、老年代
>
>​	1）Young区被划分为三部分，Eden区和两个大小严格相同的Survivor区，其中，Survivor区间中，某一时刻只有其中一个是被使用的，另外一个留做垃圾收集时复制对象用。在Eden区变满的时候， GC就会将存活的对象移到空闲的Survivor区间中，根据JVM的策略，在经过几次垃圾收集后，任然存活于Survivor的对象将被移动到Tenured区间。
>
>​	2）Tenured区主要保存生命周期长的对象，一般是一些老的对象，当一些对象在Young复制转移一定的次数以后，对象就会被转移到Tenured区。
>
>**面试官**：能不能解释一下方法区？
>
>**候选人:**
>
>好的~
>
>与虚拟机栈类似。本地方法栈是为虚拟机**执行本地方法时提供服务的**。不需要进行GC。本地方法一般是由其他语言编写。
>
>**面试官**：你听过直接内存吗？
>
>**候选人:**
>
>嗯~~
>
>它又叫做**堆外内存**，**线程共享的区域**，在 Java 8 之前有个**永久代**的概念，实际上指的是 HotSpot 虚拟机上的永久代，它用永久代实现了 JVM 规范定义的方法区功能，**主要存储类的信息，常量，静态变量**，即时编译器编译后代码等，这部分由于是在堆中实现的，受 GC 的管理，不过由于永久代有 -XX:MaxPermSize 的上限，所以如果大量动态生成类（将类信息放入永久代），很容易造成 OOM，有人说可以把永久代设置得足够大，但很难确定一个合适的大小，受类数量，常量数量的多少影响很大。
>
>​	所以在 Java 8 中就把方法区的实现移到了本地内存中的元空间中，这样方法区就不受 JVM 的控制了,也就不会进行 GC，也因此提升了性能。
>
>**面试官**：什么是虚拟机栈
>
>**候选人:**
>
>虚拟机栈是描述的是方法执行时的内存模型,是线程私有的，生命周期与线程相同,每个方法被执行的同时会创建**栈桢**。保存执行方法时的**局部变量、动态连接信息、方法返回地址信息**等等。方法开始执行的时候会进栈，方法执行完会出栈【相当于清空了数据】，所以这块区域**不需要进行 GC**。
>
>**面试官**：能说一下堆栈的区别是什么吗？
>
>**候选人:**
>
>嗯，好的，有这几个区别
>
>第一，栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组的的。堆会GC垃圾回收，而栈不会。
>
>第二、栈内存是线程私有的，而堆内存是线程共有的。
>
>第三、两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常。
>
>栈空间不足：java.lang.StackOverFlowError。
>
>堆空间不足：java.lang.OutOfMemoryError。

### 5.2 类加载器

>**面试官**：什么是类加载器，类加载器有哪些?
>
>**候选人:**
>
>嗯，是这样的
>
>JVM只会运行二进制文件，而类加载器（ClassLoader）的主要作用就是将**字节码文件加载到JVM中**，从而让Java程序能够启动起来。
>
>常见的类加载器有4个
>
>第一个是启动类加载器(BootStrap ClassLoader)：其是由C++编写实现。用于加载JAVA_HOME/jre/lib目录下的类库。
>
>第二个是扩展类加载器(ExtClassLoader)：该类是ClassLoader的子类，主要加载JAVA_HOME/jre/lib/ext目录中的类库。
>
>第三个是应用类加载器(AppClassLoader)：该类是ClassLoader的子类，主要用于加载classPath下的类，也就是加载开发者自己编写的Java类。
>
>第四个是自定义类加载器：开发者自定义类继承ClassLoader，实现自定义类加载规则。
>
>**面试官**：说一下类装载的执行过程？
>
>**候选人:**
>
>嗯，这个过程还是挺多的。
>
>类从加载到虚拟机中开始，直到卸载为止，它的整个生命周期包括了：加载、验证、准备、解析、初始化、使用和卸载这7个阶段。其中，验证、准备和解析这三个部分统称为连接（linking）
>
>1.加载：查找和导入class文件
>
>2.验证：保证加载类的准确性
>
>3.准备：为类变量分配内存并设置类变量初始值
>
>4.解析：把类中的符号引用转换为直接引用
>
>5.初始化：对类的静态变量，静态代码块执行初始化操作
>
>6.使用：JVM 开始从入口方法开始执行用户的程序代码
>
>7.卸载：当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存
>
>**面试官**：什么是双亲委派模型？
>
>**候选人:**
>
>嗯，它是是这样的。
>
>如果一个类加载器收到了类加载的请求，它首先不会自己尝试加载这个类，而是把这请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传说到顶层的启动类加载器中，只有当父类加载器返回自己无法完成这个加载请求（它的搜索返回中没有找到所需的类）时，子类加载器才会尝试自己去加载
>
>**面试官**：JVM为什么采用双亲委派机制
>
>**候选人:**
>
>主要有两个原因。
>
>第一、通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性。
>
>第二、为了安全，保证类库API不会被修改

### 5.3 垃圾回收

>**面试官**：简述Java垃圾回收机制？（GC是什么？为什么要GC）
>
>**候选人:**
>
>嗯，是这样~~
>
>为了让程序员更专注于代码的实现，而不用过多的考虑内存释放的问题，所以，在Java语言中，有了自动的垃圾回收机制，也就是我们熟悉的GC(Garbage Collection)。
>
>有了垃圾回收机制后，程序员只需要关心内存的申请即可，内存的释放由系统自动识别完成。
>
>在进行垃圾回收时，不同的对象引用类型，GC会采用不同的回收时机
>
>**面试官**：强引用、软引用、弱引用、虚引用的区别？
>
>**候选人:**
>
>嗯嗯~
>
>强引用最为普通的引用方式，表示一个对象处于**有用且必须**的状态，如果一个对象具有强引用，则GC并不会回收它。即便堆中内存不足了，宁可出现OOM，也不会对其进行回收
>
>软引用表示一个对象处于**有用且非必须**状态，如果一个对象处于软引用，在内存空间足够的情况下，GC机制并不会回收它，而在内存空间不足时，则会在OOM异常出现之间对其进行回收。但值得注意的是，因为GC线程优先级较低，软引用并不会立即被回收。
>
>弱引用表示一个对象处于**可能有用且非必须**的状态。在GC线程扫描内存区域时，一旦发现弱引用，就会回收到弱引用相关联的对象。对于弱引用的回收，无关内存区域是否足够，一旦发现则会被回收。同样的，因为GC线程优先级较低，所以弱引用也并不是会被立刻回收。
>
>虚引用表示一个对象处于**无用**的状态。在任何时候都有可能被垃圾回收。虚引用的使用必须和引用队列Reference Queue联合使用
>
>**面试官**：对象什么时候可以被垃圾器回收
>
>**候选人:**
>
>思考一会~~
>
>如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收。
>
>如果要定位什么是垃圾，有两种方式来确定，第一个是引用计数法，第二个是可达性分析算法
>
>通常都使用可达性分析算法来确定是不是垃圾
>
>**面试官**： JVM 垃圾回收算法有哪些？
>
>**候选人:**
>
>我记得一共有四种，分别是标记清除算法、复制算法、标记整理算法、分代回收
>
>**面试官**： 你能详细聊一下分代回收吗？
>
>**候选人:**
>
>关于分代回收是这样的
>
>在java8时，堆被分为了两份：新生代和老年代，它们默认空间占用比例是1:2
>
>对于新生代，内部又被分为了三个区域。Eden区，S0区，S1区默认空间占用比例是8:1:1
>
>具体的工作机制是有些情况：
>
>1）当创建一个对象的时候，那么这个对象会被分配在新生代的Eden区。当Eden区要满了时候，触发YoungGC。
>
>2）当进行YoungGC后，此时在Eden区存活的对象被移动到S0区，并且**当前对象的年龄会加1**，清空Eden区。
>
>3）当再一次触发YoungGC的时候，会把Eden区中存活下来的对象和S0中的对象，移动到S1区中，这些对象的年龄会加1，清空Eden区和S0区。
>
>4）当再一次触发YoungGC的时候，会把Eden区中存活下来的对象和S1中的对象，移动到S0区中，这些对象的年龄会加1，清空Eden区和S1区。
>
>5）对象的年龄达到了某一个限定的值（**默认15岁**  ），那么这个对象就会进入到老年代中。
>
>当然也有特殊情况，如果进入Eden区的是一个大对象，在触发YoungGC的时候，会直接存放到老年代
>
>当老年代满了之后，**触发FullGC**。**FullGC同时回收新生代和老年代**，当前只会存在一个FullGC的线程进行执行，其他的线程全部会被挂起。  我们在程序中要尽量避免FullGC的出现。
>
>**面试官**：讲一下新生代、老年代、永久代的区别？
>
>**候选人:**
>
>嗯！是这样的，简单说就是
>
>**新生代**主要用来存放新生的对象。
>
>**老年代**主要存放应用中生命周期长的内存对象。
>
>**永久代**指的是永久保存区域。主要存放Class和Meta（元数据）的信息。在Java8中，永久代已经被移除，取而代之的是一个称之为“元数据区”（**元空间**）的区域。元空间和永久代类似，不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存的限制。
>
>**面试官**：说一下 JVM 有哪些垃圾回收器？
>
>**候选人:**
>
>在jvm中，实现了多种垃圾收集器，包括：串行垃圾收集器、并行垃圾收集器（JDK8默认）、CMS（并发）垃圾收集器、G1垃圾收集器（JDK9默认）
>
>**面试官**：Minor GC、Major GC、Full GC是什么
>
>**候选人:**
>
>嗯，其实它们指的是不同代之间的垃圾回收
>
>Minor GC 发生在新生代的垃圾回收，暂停时间短
>
>Major GC 老年代区域的垃圾回收，老年代空间不足时，会先尝试触发Minor GC。Minor GC之后空间还不足，则会触发Major GC，Major GC速度比较慢，暂停时间长
>
>Full GC 新生代 + 老年代完整垃圾回收，暂停时间长，**应尽力避免**

### 5.4 JVM实践（调优）

>**面试官**：JVM 调优的参数可以在哪里设置参数值？
>
>**候选人:**
>
>我们当时的项目是springboot项目，可以在项目启动的时候，java -jar中加入参数就行了
>
>
>
>**面试官**：用的 JVM 调优的参数都有哪些？
>
>**候选人:**
>
>嗯，这些参数是比较多的
>
>我记得当时我们设置过堆的大小，像-Xms和-Xmx
>
>还有就是可以设置年轻代中Eden区和两个Survivor区的大小比例
>
>还有就是可以设置使用哪种垃圾回收器等等。具体的指令还真记不太清楚。
>
>
>
>**面试官**：嗯，好的，你们平时调试 JVM都用了哪些工具呢？
>
>**候选人:**
>
>嗯，我们一般都是使用jdk自带的一些工具，比如
>
>jps 输出JVM中运行的进程状态信息
>
>jstack查看java进程内**线程的堆栈**信息。
>
>jmap 用于生成堆转存快照
>
>jstat用于JVM统计监测工具
>
>还有一些可视化工具，像jconsole和VisualVM等
>
>**面试官**：假如项目中产生了java内存泄露，你说一下你的排查思路？
>
>**候选人:**
>
>嗯，这个我在之前项目排查过
>
>第一呢可以通过jmap指定打印他的内存快照 dump文件，不过有的情况打印不了，我们会设置vm参数让程序自动生成dump文件
>
>第二，可以通过工具去分析 dump文件，jdk自带的VisualVM就可以分析
>
>第三，通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题
>
>第四，找到对应的代码，通过阅读上下文的情况，进行修复即可
>
>**面试官**：好的，那现在再来说一种情况，就是说服务器CPU持续飙高，你的排查方案与思路？
>
>**候选人:**
>
>嗯，我思考一下~~
>
>可以这么做~~
>
>第一可以使用使用top命令查看占用cpu的情况
>
>第二通过top命令查看后，可以查看是哪一个进程占用cpu较高，记录这个进程id
>
>第三可以通过ps 查看当前进程中的线程信息，看看哪个线程的cpu占用较高
>
>第四可以jstack命令打印进行的id，找到这个线程，就可以进一步定位问题代码的行号