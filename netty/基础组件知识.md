# netty
## 简介
netty是一个异步的，基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端
netty的异步是基于多路复用的，没有实现真正意义上的异步IO
## 优势
1. **高性能**：
 - Netty经过精心设计和优化，以实现卓越的性能。它采用异步、非阻塞的事件驱动模型，允许处理大量并发连接而不会导致线程资源耗尽。
  - Netty还通过使用零拷贝技术和内存池来最小化内存分配和数据复制，从而提高了数据处理的效率。
2. **多协议支持**：
   - Netty支持多种常见的网络协议，包括TCP、UDP、HTTP、WebSocket等。这使得它适用于构建各种类型的网络应用程序，从传统的服务器到实时Web应用。
3. **模块化和可扩展**：
  - Netty的设计采用了模块化的思想，你可以选择性地添加和配置组件，以适应不同的需求。
  - 它提供了丰富的事件处理器和编解码器，以便你可以构建复杂的通信管道。
# 组件
1.channel 可以理解为数据的通道
2.msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 中的各个 handler 加工，会变成其它类型对象，最后输出又变成 ByteBuf
3.handler 可以理解为数据的处理工序
工序有多道，合在一起就是 pipeline（传递途径），pipeline 负责发布事件（读、读取完成…）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）
4.pipeline 中有多个 handler，处理时会依次调用其中的 handler
5.handler 分 Inbound 和 Outbound 两类
6.eventLoop 可以理解为处理数据的工人
- eventLoop 可以管理多个 channel 的 io 操作，并且一旦 eventLoop 负责了某个 channel，就会将其与channel进行绑定，以后该 channel 中的 io 操作都由该 eventLoop 负责
- eventLoop 既可以执行 io 操作，也可以进行任务处理，每个 eventLoop 有自己的任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务
- eventLoop 按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每个 handler 指定不同的 eventLoop
## EventLoop
### 事件
1. **事件类型**：
    - **连接事件**：当客户端与服务器建立连接或连接关闭时，会触发连接事件。
    - **数据事件**：数据事件包括数据的读取和写入。当有数据可读取时，会触发读事件。当数据被写入到通道时，会触发写事件。
    - **异常事件**：当发生异常，如IO异常或处理异常时，会触发异常事件。
    - **自定义事件**：除了内置事件，你还可以定义自己的事件，用于特定的业务需求。
2. **设置事件处理器**：
    - 为了处理这些事件，你需要创建相应类型的事件处理器（Handler），例如`ChannelInboundHandler`用于处理入站事件，`ChannelOutboundHandler`用于处理出站事件。
    - 通过向Pipeline中添加这些事件处理器，你可以将事件处理逻辑与特定事件关联起来。例如，使用`pipeline.addLast(new MyHandler())`来添加自定义事件处理器。
3. **触发事件**：
    - 事件通常是由Netty框架自动触发的，当有事件发生时，Netty会调用相应的事件处理器的方法。例如，当有数据可读取时，会调用`channelRead()`方法。
    - 你也可以手动触发事件，例如，通过调用`ctx.fireUserEventTriggered(myEvent)`来触发自定义事件。
4. **事件传播**：
    - 事件可以在Pipeline中传播，经过一系列的事件处理器。默认情况下，事件会从一个Handler传递到下一个Handler。
    - 你可以通过事件处理器的方法来控制事件传播，例如，使用`ctx.write()`来将数据写入通道，并继续传播写事件。
5. **事件处理逻辑**：
    - 在事件处理器中，你可以编写自定义的业务逻辑，以响应特定事件。例如，你可以在`channelRead()`方法中处理接收到的数据，或在`exceptionCaught()`方法中处理异常。
### 事件循环对象EventLoop
其本质是一个单线程执行器（同时维护了一个Selector），里面有run方法处理一个或多个Channel上源源不断的io事件
继承关系：
- 继承自 j.u.c.ScheduledExecutorService 
   因此包含了线程池中所有的方法
- 继承自 netty 自己的 OrderedEventExecutor
提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop
提供了 EventLoopGroup parent() 方法来看看自己属于哪个 EventLoopGroup
### 事件循环组EventLoopGroup
EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）
继承关系：
继承自 netty 自己的 EventExecutorGroup
  - 实现了 Iterable 接口提供遍历 EventLoop 的能力
  - 另有 next 方法获取集合中下一个 EventLoop
### 处理普通任务或定时任务
- eventloopgroup的next方法可以获得下一个eventloop
- eventloop的execute方法可以执行普通任务
- eventloop的scheduleAtFixedRate方法可以执行定时任务
- eventloopgroup的shutdownGracefully方法可以优雅的关闭
该方法会首先切换 EventLoopGroup到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的
```
public class TestEventLoop {
    public static void main(String[] args) {
        // 创建拥有两个EventLoop的NioEventLoopGroup，对应两个线程
        EventLoopGroup group = new NioEventLoopGroup(2);
        // 通过next方法可以获得下一个 EventLoop
        System.out.println(group.next());
        System.out.println(group.next());

        // 通过EventLoop执行普通任务
        group.next().execute(()->{
            System.out.println(Thread.currentThread().getName() + " hello");
        });

        // 通过EventLoop执行定时任务
        group.next().scheduleAtFixedRate(()->{
            System.out.println(Thread.currentThread().getName() + " hello2");
        }, 0, 1, TimeUnit.SECONDS);
        
        // 优雅地关闭
        group.shutdownGracefully();
    }
}

```
### 处理IO任务
```
//服务器端代码
public class MyServer {
    public static void main(String[] args) {
        new ServerBootstrap()
                .group(new NioEventLoopGroup())
                .channel(NioServerSocketChannel.class)
                .childHandler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    protected void initChannel(SocketChannel socketChannel) throws Exception {
                        socketChannel.pipeline().addLast(new ChannelInboundHandlerAdapter() {
                            @Override
                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
                                ByteBuf buf = (ByteBuf) msg;
                                System.out.println(Thread.currentThread().getName() + " " + buf.toString(StandardCharsets.UTF_8));

                            }
                        });
                    }
                })
                .bind(8080);
    }
}
```
关于channelRead方法：
- 作用：`channelRead`方法是一个事件处理器方法，用于处理当有数据从客户端传入服务器时的事件。在这个方法中，你可以处理接收到的数据。
- 参数说明：
    - `ctx`：ChannelHandlerContext对象，表示处理事件的上下文，它包含了与Channel相关的信息和操作方法。可以理解为一个工具用来获取关于channel相关的信息或数据，其中的内容由netty自动装填，只需调用方法获取即可
    - `msg`：表示接收到的数据，通常是ByteBuf类型，需要根据通信协议进行解析。
关于initChannel方法：
- 作用：`initChannel`方法是另一个事件处理器方法，它用于初始化Channel的处理器链（ChannelPipeline）。在这个方法中，你可以添加不同的事件处理器来处理各种事件。
- 参数说明：
    - `socketChannel`：SocketChannel对象，表示客户端与服务器之间的通道。
- 代码逻辑：在这个示例中，`initChannel`方法向SocketChannel的处理器链中添加了一个匿名的`ChannelInboundHandlerAdapter`。这个处理器负责处理`channelRead`事件，即接收到的数据的处理。
```
//客户端代码
public class MyClient {
    public static void main(String[] args) throws IOException, InterruptedException {
        Channel channel = new Bootstrap()
                .group(new NioEventLoopGroup())
                .channel(NioSocketChannel.class)
                .handler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    protected void initChannel(SocketChannel socketChannel) throws Exception {
                        socketChannel.pipeline().addLast(new StringEncoder());
                    }
                })
                .connect(new InetSocketAddress("localhost", 8080))
                .sync()
                .channel();
        System.out.println(channel);
        // 此处打断点调试，调用 channel.writeAndFlush(...);
        System.in.read();
    }
}
```
### eventloop和channel的对应关系
一个EventLoop可以**负责多个**Channel，且EventLoop一旦与Channel绑定，则**一直负责**处理该Channel中的事件
1. **一个EventLoop管理多个Channel**：一个EventLoop是一个单线程或少数几个线程的执行环境，它负责处理多个Channel上的事件。这些Channel可以是客户端与服务器的连接，也可以是服务器接受的多个客户端连接。多个Channel共享一个EventLoop，这样可以减少线程的创建和维护成本。
2. **一个Channel只被一个EventLoop处理**：一旦一个Channel被创建或接受连接时，它会被绑定到一个特定的EventLoop。从那时起，这个Channel上的所有事件，如数据读取、写入、连接建立和关闭等，都由绑定的EventLoop负责处理。这确保了事件的顺序性和一致性。
这种模型允许Netty有效地管理多个连接，提供了高度的并发性，同时避免了线程管理的复杂性和开销。每个EventLoop在一个独立的线程上运行，它可以处理多个Channel的事件，而无需创建大量线程，从而在资源利用和性能方面具有优势。这是Netty构建高性能网络应用程序的关键之一。
### 自定义EventLoopGroup
当有的**任务需要较长的时间处理时，可以使用非NioEventLoopGroup**，避免同一个NioEventLoop中的其他Channel在较长的时间内都无法得到处理
Netty提供了不同类型的EventLoopGroup，以满足不同应用场景的需求。以下是一些常见的EventLoopGroup类型：
1. **NioEventLoopGroup**：这是最常见的EventLoopGroup类型，适用于基于NIO的网络应用程序。它使用Java的NIO库来进行非阻塞网络通信。
2. **OioEventLoopGroup**：这是一个EventLoopGroup，适用于基于旧的阻塞式I/O（OIO，Old I/O）的网络应用程序。它在处理方式上与NioEventLoopGroup不同，通常用于兼容旧的阻塞式I/O代码。
3. **EpollEventLoopGroup**：这个EventLoopGroup专为基于Linux的应用程序设计，它使用了Linux上的epoll机制，提供了更高的性能和可伸缩性。
4. **KQueueEventLoopGroup**：这个EventLoopGroup也是为特定平台设计的，适用于基于FreeBSD和macOS的应用程序。它使用了KQueue事件通知机制，提供了高性能的事件处理。
5. **DefaultEventLoopGroup**：这是一个通用的EventLoopGroup，它适用于执行一般的任务，而不涉及网络通信。它可以用于处理非网络相关的任务。
6. **GlobalEventExecutor**：这是一个全局的EventExecutor，通常用于执行异步任务，而不需要创建专门的EventLoopGroup。它是一个单例实例，可在整个应用程序中共享。
### 关于线程切换
在Netty中，一个EventLoop通常负责处理多个Channel上的事件，这些事件包括数据读取、写入、连接建立、连接关闭等。EventLoop的工作方式是事件驱动的，它会在一个无限循环中等待事件的发生，一旦事件发生，就会调用相应的事件处理器方法来处理事件。

现在，让我们考虑以下情况：
1. 假设一个EventLoop正在处理一个Channel上的事件，例如读取数据。
2. 同时，另一个Channel上的事件也发生了，例如连接建立。

在这种情况下，两个Channel上的事件都需要被处理，但是问题是，一个EventLoop在同一时间只能处理一个事件。因此，需要一种机制来处理这种情况。这就是线程切换发挥作用的时候。

具体来说：
- 当第一个Channel上的事件正在被处理时，EventLoop会等待第二个Channel上的事件。但如果EventLoop一直在等待，那么第一个Channel上的事件将无法及时处理。
- 为了解决这个问题，Netty采用了线程切换的方式。当第二个Channel上的事件发生时，Netty可以将处理第二个事件的任务切换到另一个线程上，从而不影响第一个Channel上事件的处理。这个线程切换通常是通过执行器（Executor）来实现的。

所以，线程切换的主要目的是确保多个Channel上的事件都能够及时得到处理，而不会被阻塞。切换的是事件处理的上下文，即将事件处理的线程从一个EventLoop切换到另一个线程，以便同时处理多个事件。
总结来说，线程切换是Netty为了提高并发性和响应性而采用的一种机制，它确保多个Channel上的事件都能得到及时处理，而不会阻塞其他事件的处理。这是Netty的事件驱动和非阻塞模型的关键之一。
```
static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) {
    final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, "msg"), next);
    // 获得下一个EventLoop, excutor 即为 EventLoopGroup
    EventExecutor executor = next.executor();
    
    // 如果下一个EventLoop 在当前的 EventLoopGroup中
    if (executor.inEventLoop()) {
        // 使用当前 EventLoopGroup 中的 EventLoop 来处理任务
        next.invokeChannelRead(m);
    } else {
        // 否则让另一个 EventLoopGroup 中的 EventLoop 来创建任务并执行
        executor.execute(new Runnable() {
            public void run() {
                next.invokeChannelRead(m);
            }
        });
    }
}
```
- 如果两个 handler 绑定的是**同一个EventLoopGroup**，那么就直接调用
- 否则，把要调用的代码封装为一个任务对象，由下一个 handler 的 EventLoopGroup 来调用
结合后面的`Future`和`Promise`理解
## Channel
### 常用方法
- close() 可以用来关闭Channel
- closeFuture() 用来处理 Channel 的关闭
- sync 方法作用是同步等待 Channel 关闭，调用线程等待
- addListener 方法是异步等待 Channel 关闭，非调用线程
- pipeline() 方法用于添加处理器
- write() 方法将数据写入
- writeAndFlush() 方法将数据写入并立即发送（刷出），相当于write() + flush()
因为缓冲机制，数据被写入到 Channel 中以后，不会立即被发送
只有当缓冲满了或者调用了flush()方法后，才会将数据通过 Channel 发送出去，或者缓冲区数据达到可发送界限
### ChannelFuture
#### 连接建立异步问题（关于sync方法）
```
public class MyClient {
    public static void main(String[] args) throws IOException, InterruptedException {
        ChannelFuture channelFuture = new Bootstrap()
                .group(new NioEventLoopGroup())
                .channel(NioSocketChannel.class)
                .handler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    protected void initChannel(SocketChannel socketChannel) throws Exception {
                        socketChannel.pipeline().addLast(new StringEncoder());
                    }
                })
                // 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程
            	// NIO线程：NioEventLoop 中的线程
                .connect(new InetSocketAddress("localhost", 8080));
        
        // 该方法用于等待连接真正建立
        channelFuture.sync();
        
        // 获取客户端-服务器之间的Channel对象
        Channel channel = channelFuture.channel();
        channel.writeAndFlush("hello world");
        System.in.read();
    }
}
```
上述代码中如果我们去掉channelFuture.sync()方法，会使服务器无法收到hello world
这是因为建立连接(connect)的过程是异步非阻塞的，若不通过sync()方法阻塞主线程(调用线程)，等待连接真正建立，这时通过 channelFuture.channel() 拿到的 Channel 对象，还未真正与服务器建立好连接，也就没法将信息正确的传输给服务器端
解决方法：
方法一：所以需要通过channelFuture.sync()方法，阻塞主线程，同步处理结果，等待连接真正建立好以后，再去获得 Channel 传递数据。使用该方法，获取 Channel 和发送数据的线程都是主线程
方法二：用于异步获取建立连接后的 Channel 和发送数据，使得执行这些操作的线程是 NIO(eventLoop) 线程（去执行connect操作的线程）

在Netty中，`sync`方法是一个用于同步等待某个操作完成的方法。它通常与`Future`或`ChannelFuture`对象一起使用，用于等待操作完成并获取其结果。让我们更详细地理解`sync`方法的作用和用法：
1. **等待操作完成**：`sync`方法会阻塞当前线程，直到与其关联的`Future`或`ChannelFuture`对象表示的操作完成为止。这意味着在调用`sync`方法之后，程序会暂停执行，直到操作成功完成或失败。
2. **获取操作结果**：一旦操作完成，`sync`方法会返回`Future`或`ChannelFuture`对象，你可以使用这个对象来检查操作的结果或执行后续的操作。通常，你可以调用`isSuccess()`方法来检查操作是否成功，或使用`cause()`方法来获取失败的原因。
3. **异常处理**：如果操作失败，你可以使用`sync`返回的`Future`或`ChannelFuture`对象的`cause()`方法来获取失败的原因。这使得你可以根据具体的异常情况来处理错误。
4. **典型用途**：`sync`方法通常在一些需要等待操作完成的场景中使用，例如等待服务器启动完成、等待连接建立完成等。它有助于控制流程，确保在必要的时候等待操作完成再继续执行后续操作。
#### 关于addListener方法
在Netty中，`addListener`方法用于向`Future`或`ChannelFuture`对象添加一个监听器（listener），以便在操作完成时执行特定的操作或回调函数。这个方法允许异步地处理操作结果，而不必使用`sync`方法来阻塞等待。以下是关于`addListener`方法的详细解释和用法：
1. **添加监听器**：`addListener`方法接受一个`GenericFutureListener`作为参数，这个监听器负责在操作完成时执行特定的逻辑。
2. **异步操作**：通过使用`addListener`，你可以异步地处理操作完成事件，而不需要阻塞当前线程。这对于避免阻塞并提高程序的响应性非常有用。
3. **多个监听器**：你可以多次调用`addListener`方法，以便在同一个`Future`或`ChannelFuture`对象上添加多个监听器，每个监听器都可以执行不同的逻辑。
4. **操作完成时执行**：监听器中的逻辑将在操作成功完成或失败时执行。你可以在监听器的回调方法中检查操作的成功或失败状态，并采取适当的行动。
5. **典型用途**：`addListener`方法通常用于处理连接建立、数据读取、数据写入等操作的完成事件。例如，在连接建立后执行一些初始化操作，或在数据写入完成后执行一些后续处理。
```
public class MyClient {
    public static void main(String[] args) throws IOException, InterruptedException {
        ChannelFuture channelFuture = new Bootstrap()
                .group(new NioEventLoopGroup())
                .channel(NioSocketChannel.class)
                .handler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    protected void initChannel(SocketChannel socketChannel) throws Exception {
                        socketChannel.pipeline().addLast(new StringEncoder());
                    }
                })
                // 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程
                // NIO线程：NioEventLoop 中的线程
                .connect(new InetSocketAddress("localhost", 8080));
        
		// 当connect方法执行完毕后，也就是连接真正建立后
        // 会在NIO线程中调用operationComplete方法
        channelFuture.addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture channelFuture) throws Exception {
                Channel channel = channelFuture.channel();
                channel.writeAndFlush("hello world");
            }
        });
    }
}
```
#### 关闭channel
当我们要关闭channel时，可以调用channel.close()方法进行关闭。但是该方法也是一个异步方法。真正的关闭操作并不是在调用该方法的线程中执行的，而是在NIO线程中执行真正的关闭操作

如果我们想在channel真正关闭以后，执行一些额外的操作，可以选择以下两种方法来实现
1.通过channel.closeFuture()方法获得对应的ChannelFuture对象，然后调用sync()方法阻塞执行操作的线程，待channel真正关闭后，再执行其他操作
```
// 获得closeFuture对象
ChannelFuture closeFuture = channel.closeFuture();

// 同步等待NIO线程执行完close操作
closeFuture.sync();
```
2.调用closeFuture.addListener方法，添加close的后续操作
```
closeFuture.addListener(new ChannelFutureListener() {
    @Override
    public void operationComplete(ChannelFuture channelFuture) throws Exception {
        // 等待channel关闭后才执行的操作
        System.out.println("关闭之后执行一些额外操作...");
        // 优雅的关闭EventLoopGroup
        group.shutdownGracefully();
    }
});
```
### Future和promise
netty 中的 Future 与 jdk 中的 Future 同名，但是是两个接口
netty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展
#### 基本使用
- jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果
- netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但都是要等任务结束
- netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，只作为两个线程间传递结果的容器
![[Pasted image 20230927165533.png]]
#### JDK future、netty future、netty promise对比
1. **JDK Future**:
    - **功能**：JDK Future是用于表示异步操作结果的接口，可以用于获取操作的结果或等待操作完成。
    - **特点**：JDK Future是只读的，一旦异步操作完成，它就可以用来获取操作的结果。但是，它不能被用来修改或标记操作的完成状态。
    - **使用**：通常通过`get()`方法来等待操作完成并获取结果。但要小心，`get()`方法会阻塞当前线程，直到操作完成。
    - **缺点**：JDK Future在处理复杂的异步场景时有限，不能手动设置操作的完成状态。
2. **Netty Future**:
    - **功能**：Netty Future是一个接口，类似于JDK Future，用于表示异步操作的结果。它提供了异步操作的结果查询和监听的能力。
    - **特点**：Netty Future是可写的，你可以手动设置操作的完成状态，并添加监听器来处理操作完成时的事件。
    - **使用**：通过`addListener()`方法添加监听器来处理异步操作的结果，也可以通过`isDone()`方法查询操作是否完成。
    - **优点**：Netty Future相对灵活，允许你更精细地控制异步操作的状态和事件。
3. **Netty Promise**:
    - **功能**：Netty Promise是Netty的扩展，它实现了Netty Future接口，并提供了更多的功能。Promise除了表示异步操作的结果外，还允许你手动设置操作的结果或失败原因。
    - **特点**：Promise是可写的，你可以通过`setSuccess()`或`setFailure()`方法手动设置操作的完成状态。这使得你可以更主动地控制操作的结果。
    - **使用**：Promise通常用于在自定义的异步方法中，以便你可以更灵活地管理操作的完成状态。它还可以作为Future的子类使用。
    - **优点**：Promise提供了更多的控制权，适用于需要手动操作异步操作结果的情况。
#### netty future使用
Netty中的Future对象，可以通过EventLoop的sumbit()方法得到
- 可以通过Future对象的get方法，阻塞地获取返回结果
- 也可以通过getNow方法，获取结果，若还没有结果，则返回null，该方法是非阻塞的
- 还可以通过future.addListener方法，在Callable方法执行的线程中，异步获取返回结果
#### netty promise使用
Promise相当于一个容器，可以用于存放各个线程中的结果，然后让其他线程去获取该结果
```
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.util.concurrent.DefaultPromise;
import io.netty.util.concurrent.EventExecutor;
import io.netty.util.concurrent.Future;
import io.netty.util.concurrent.Promise;

public class MyHandler extends ChannelInboundHandlerAdapter {
    private final EventExecutor eventExecutor;

    public MyHandler(EventExecutor eventExecutor) {
        this.eventExecutor = eventExecutor;
    }

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        // 判断是否在同一个EventLoopGroup中
        if (ctx.executor() == eventExecutor) {
            // 如果在同一个EventLoopGroup中，直接处理消息
            doTask(msg, ctx);
        } else {
            // 否则，封装任务并提交给下一个EventLoopGroup执行
            submitTask(msg, ctx);
        }
    }

    private void doTask(Object msg, ChannelHandlerContext ctx) {
        // 直接处理消息
        // ...
    }

    private void submitTask(Object msg, ChannelHandlerContext ctx) {
        // 创建一个Promise，表示任务的异步执行结果
        Promise<Object> promise = new DefaultPromise<>(eventExecutor);

        // 将任务封装为一个Runnable
        Runnable task = () -> {
            try {
                doTask(msg, ctx);
                promise.setSuccess(null); // 标记任务成功完成
            } catch (Exception e) {
                promise.setFailure(e); // 标记任务执行失败
            }
        };

        // 提交任务给下一个EventLoopGroup执行
        eventExecutor.execute(task);

        // 可以在需要的地方等待任务完成，或者添加回调处理
        promise.addListener(future -> {
            if (future.isSuccess()) {
                // 任务成功完成
            } else {
                // 任务执行失败
                Throwable cause = future.cause();
                // 处理异常
            }
        });
    }
}
```
## Handler和Pipeline
### Pipeline
pipeline是结构是一个带有head与tail指针的双向链表，其中的节点为handler
要通过ctx.fireChannelRead(msg)等方法，将当前handler的处理结果传递给下一个handler
当事件发生时，它首先进入Channel的Pipeline，然后从Pipeline的第一个Handler开始流经整个Pipeline链，每个Handler可以处理、修改或传递事件。最终，事件将到达Pipeline的末尾并被丢弃或写回到连接的对端。Pipeline负责管理Handler链的顺序，可以通过Pipeline的方法添加、删除或替换Handler，以适应不同的处理需求。
当有入站（Inbound）操作时，会从head开始向后调用handler，直到handler不是处理Inbound操作为止
当有出站（Outbound）操作时，会从tail开始向前调用handler，直到handler不是处理Outbound操作为止
![[Pasted image 20230930113549.png]]
![[Pasted image 20230930113613.png]]
尽管可以采取将对某个事件的所有操作通过一个handler来执行的方式，但在实际网络应用程序中，通常使用Pipeline和多个Handler的方式分离了关注点，提高了代码的可维护性、可读性和扩展性，是Netty的一种良好实践。
### Handler
Handler是用于处理网络事件的组件，它执行特定的业务逻辑以响应事件，如数据读取、数据写入、连接建立、连接关闭等。每个Handler都是一个Java类，实现了Netty提供的特定接口或继承了特定类，以便处理各种类型的事件。
通过channel.pipeline().addLast(name, handler)添加handler时，**记得给handler取名字**。这样可以调用pipeline的addAfter、addBefore等方法更灵活地向pipeline中添加handler
#### OutboundHandler
- socketChannel.writeAndFlush()
当handler中调用该方法进行写操作时，会触发Outbound操作，此时是从tail向前寻找OutboundHandler
- ctx.writeAndFlush()
当handler中调用该方法进行写操作时，会触发Outbound操作，此时是从当前handler向前寻找
#### EmbeddedChannel
EmbeddedChannel可以用于测试各个handler，通过其构造函数按顺序传入需要测试handler，然后调用对应的Inbound和Outbound方法即可
```
	//h1,h2ChannelInboundHandlerAdapter,h3,h4ChannelOutboundHandlerAdapter
    // 用于测试Handler的Channel
    EmbeddedChannel channel = new EmbeddedChannel(h1, h2, h3, h4);   
	// 执行Inbound操作               
	channel.writeInbound(ByteBufAllocator.DEFAULT.buffer().
		writeBytes("hello".getBytes(StandardCharsets.UTF_8)));
    // 执行Outbound操作      
    channel.writeOutbound(ByteBufAllocator.DEFAULT.buffer().
        writeBytes("hello".getBytes(StandardCharsets.UTF_8)));
```
## Bytebuf
创建byteBuf（直接内存，而不是堆内存），默认大小是256，通过该方式创建的ByteBuf对象会自动扩容，与nio的ByteBuffer不一样，nio达到扩容期限之后，会报错抛出 BufferOverflowException 的异常
```
ByteBuf byteBuf = ByteBufAllocator.DEFAULT.buffer(32);
```
使用ByteBufAllocator创建直接内容，容量为256个字节,直接内容不需要考虑GC回收，默认获取的 byteBuf 便是直接内存，需要主动释放关闭
```
ByteBuf directBuffer = ByteBufAllocator.DEFAULT.directBuffer();
```
使用ByteBufAllocator创建堆内存
```
ByteBuf heapBuffer = ByteBufAllocator.DEFAULT.heapBuffer();
```
如果在handler中创建ByteBuf，建议使用`ChannelHandlerContext ctx.alloc().buffer()`来创建
### 直接内存与堆内存
通过该方法创建的ByteBuf，使用的是基于直接内存的ByteBuf
```
ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(16);
```
可以使用下面的代码来创建池化基于堆的 ByteBuf
```
ByteBuf buffer = ByteBufAllocator.DEFAULT.heapBuffer(16);
```
也可以使用下面的代码来创建池化基于直接内存的 ByteBuf
```
ByteBuf buffer = ByteBufAllocator.DEFAULT.directBuffer(16);
```
直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用
直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放
### 池化与非池化
1. **池化（Pooled）ByteBuf**：
    - 池化`ByteBuf`是由Netty的内存管理系统管理的，它们被重复使用，可以降低内存分配和释放的开销。
    - 池化`ByteBuf`通常是通过`PooledByteBufAllocator`创建的，这是Netty的默认分配器。
    - 优点：
        - 重用：池化`ByteBuf`可以被多次重复使用，减少了频繁的内存分配和垃圾回收。
        - 性能：减少了内存分配和垃圾回收的开销，提高了性能。
    - 注意事项：
        - 需要手动释放：你需要手动调用`release()`方法来释放池化`ByteBuf`，以确保将其返回到池中以供重用。如果忘记释放，可能会导致内存泄漏。
        - 适用于长时间的复用：池化`ByteBuf`适用于长时间复用的场景，例如持久化连接。
2. **非池化（Unpooled）ByteBuf**：
    - 非池化`ByteBuf`不由Netty的内存管理系统管理，每次都会分配新的内存。
    - 非池化`ByteBuf`通常是通过`Unpooled`工具类创建的。
    - 优点：
        - 简单：无需手动释放，适用于一次性使用的场景。
        - 避免内存泄漏：不需要担心忘记释放的问题。
    - 注意事项：
        - 频繁分配内存：由于每次都分配新的内存，对于频繁创建和销毁`ByteBuf`的场景，可能会产生较大的内存分配开销。
        - 不适合持久连接：不适合用于需要长时间维护的持久连接，因为没有内置的重用机制。
如果需要在高并发情况下降低内存分配和垃圾回收的开销，池化`ByteBuf`是一个不错的选择。
但要注意在使用池化`ByteBuf`时要小心释放资源，以避免内存泄漏。如果只需要一次性使用或者需要简化内存管理，非池化`ByteBuf`可能更适合。
### 组成
ByteBuf主要有以下几个组成部分
**最大容量与当前容量**
在构造ByteBuf时，可传入两个参数，分别代表初始容量和最大容量，若未传入第二个参数（最大容量），最大容量默认为Integer.MAX_VALUE
当ByteBuf容量无法容纳所有数据时，会进行扩容操作，达到一个按需索取，若超出最大容量，会抛出java.lang.IndexOutOfBoundsException异常
**position**
读写操作不同于ByteBuffer只用position进行控制，
ByteBuf分别由读指针和写指针两个指针控制。进行读写操作时，无需进行模式的切换，初始状态，读写指针都是在0位置
读指针前的部分被称为废弃部分，是已经读过的内容
读指针与写指针之间的空间称为可读部分
写指针与当前容量之间的空间称为可写部分
![[Pasted image 20230930123603.png]]
### 写入
- 这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用来写入不同的数据
- 网络传输中，**默认习惯是 Big Endian**，使用 writeInt(int value)
- 还有一类方法是 **set 开头**的一系列方法，也可以写入数据，但不会改变写指针位置
![[Pasted image 20230930123640.png]]
### 扩容规则
如果写入后数据大小未超过 512 字节，则选择下一个 16 的整数倍进行扩容
例如写入后大小为 12 字节，则扩容后 capacity 是 16 字节，如果写入后的大小为17个字节，则扩容之后的 capacity 是32字节
如果写入后数据大小超过 512 字节，则选择下一个 2^n
例如写入后大小为 513 字节，则扩容后 capacity 是 2^10=1024 字节（2^9=512 已经不够了）
扩容不能超过 maxCapacity，否则会抛出java.lang.IndexOutOfBoundsException异常
### 读取
读取主要是通过一系列read方法进行读取，读取时会根据读取数据的字节数移动读指针
如果需要**重复读取**，需要调用`buffer.markReaderIndex()`对读指针进行标记，并通过`buffer.resetReaderIndex()`将读指针恢复到mark标记的位置
还有以 get 开头的一系列方法，这些**方法不会改变读指针的位置**
### 释放
由于 Netty 中有堆外内存（直接内存）的 ByteBuf 实现，堆外内存最好是手动来释放，而不是等 GC 垃圾回收。
UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可
UnpooledDirectByteBuf 使用的是直接内存了，需要特殊的方法来回收内存
PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存

Netty采用了引用计数法来控制回收内存，每个 ByteBuf 都实现了 ReferenceCounted 接口
1.每个 ByteBuf 对象的初始计数为 1
2.调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收
3.调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收
4.当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用
#### 释放规则
因为 pipeline 的存在，存在多个handler，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果在每个 ChannelHandler 中都去调用 release ，就失去了传递性（如果在这个 ChannelHandler 内这个 ByteBuf 已完成了它的使命，那么便无须再传递）
**基本规则是，谁是最后使用者，谁负责 release**
起点，对于 NIO 实现来讲，在 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe.read 方法中首次创建 ByteBuf 放入 pipeline（line 163 pipeline.fireChannelRead(byteBuf)）

入站 ByteBuf 处理原则
- 对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release
- 将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，必须 release
- 如果不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release
- 注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release
- 假设消息一直向后传，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）

出站 ByteBuf 处理原则
- 出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release

异常处理原则
- 有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以循环调用 release 直到返回 true

当ByteBuf被传到了pipeline的head与tail时，ByteBuf会被其中的方法彻底释放，但前提是ByteBuf被传递到了head与tail中
```
//TailConext中释放ByteBuf的源码
protected void onUnhandledInboundMessage(Object msg) {
    try {
        logger.debug("Discarded inbound message {} 
        that reached at the tail of the pipeline. Please check your pipeline configuration.", msg);
    } finally {
        // 具体的释放方法
        ReferenceCountUtil.release(msg);
    }
}
//判断传过来的是否为ByteBuf，是的话才需要释放
public static boolean release(Object msg) {
	return msg instanceof ReferenceCounted ? ((ReferenceCounted)msg).release() : false;
}
```
### 切片和组合
ByteBuf切片是【零拷贝】的体现之一
- 对原始 ByteBuf 进行切片成多个 ByteBuf,切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存，切片后的 ByteBuf 维护独立的 read，write 指针
- 得到分片后的buffer后，要调用其retain方法，使其内部的引用计数加一。避免原ByteBuf释放，导致切片buffer无法使用
- 修改原ByteBuf中的值，也会影响切片后得到的ByteBuf
```
public class TestSlice {
    public static void main(String[] args) {
        // 创建ByteBuf
        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(16, 20);

        // 向buffer中写入数据
        buffer.writeBytes(new byte[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10});

        // 将buffer分成两部分
        ByteBuf slice1 = buffer.slice(0, 5);
        ByteBuf slice2 = buffer.slice(5, 5);

        // 需要让分片的buffer引用计数加一
        // 避免原Buffer释放导致分片buffer无法使用
        slice1.retain();
        slice2.retain();
        
        ByteBufUtil.log(slice1);
        log(slice2);

        // 更改原始buffer中的值
        System.out.println("===========修改原buffer中的值===========");
        buffer.setByte(0,5);

        System.out.println("===========打印slice1===========");
        log(slice1);
    }
}
```

使用CompositeByteBuf可将小的byteBuf组合成大的bytebuf，且不发生数据的复制拷贝
```
public class TestCompositeByteBuf {
    public static void main(String[] args) {
        ByteBuf byteBuf1 = ByteBufAllocator.DEFAULT.buffer();
        byteBuf1.writeBytes(new byte[]{1, 2, 3, 4, 5});

        ByteBuf byteBuf2 = ByteBufAllocator.DEFAULT.buffer();
        byteBuf2.writeBytes(new byte[]{6, 7, 8, 9, 10});

        // 此种写法将小的byteBuf合成打的byteBuf，但是会发生内容数据的拷贝，以下发生了两次复制
        ByteBuf byteBuf3 = ByteBufAllocator.DEFAULT.buffer();
        byteBuf3.writeBytes(byteBuf1).writeBytes(byteBuf2);
        log(byteBuf3);

        // 优点，不会发生数据的拷贝，缺点：增加了维护的负复杂性
        CompositeByteBuf compositeByteBuf = ByteBufAllocator.DEFAULT.compositeBuffer();
        compositeByteBuf.addComponents(true, byteBuf1, byteBuf2);
        log(compositeByteBuf);
    }
}
```
优势
- 池化思想 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能
- 读写指针分离，不需要像 ByteBuffer 一样切换读写模式
- 可以自动扩容
- 支持链式调用，使用更流畅
- 很多地方体现零拷贝，例如slice、duplicate、CompositeByteBuf
# 小结
## 组件之间的调用链关系
在Netty中，EventLoop、Pipeline、Channel、Handler等组件之间形成了一个复杂的调用链，它们协同工作以处理网络事件。下面是它们之间的典型调用链：
1. **EventLoop（事件循环）**：
    - EventLoop是一个单线程或多线程的事件处理引擎，负责处理所有Channel的事件。
    - EventLoop不断地从Channel的任务队列中取出事件，并将事件分发给对应的Channel的Pipeline进行处理。
2. **Channel（通道）**：
    - Channel表示一个底层的网络连接，可以是TCP连接、UDP连接等。每个Channel都有一个与之关联的Pipeline。
    - 当有事件发生时，Channel会将事件委托给它所关联的EventLoop来处理。
3. **Pipeline（管道）**：
    - Pipeline是一组按顺序排列的Handler组成的事件处理链。每个Channel都有一个与之关联的Pipeline。
    - 当事件发生时，Pipeline会按照一定的顺序将事件传递给每个Handler进行处理，从头部（第一个Handler）到尾部（最后一个Handler）。
4. **Handler（处理器）**：
    - Handler是用于处理事件的组件，它可以是入站处理器（处理入站事件）或出站处理器（处理出站事件）。
    - 当事件被传递给Handler时，Handler执行特定的业务逻辑，然后可以将事件传递给下一个Handler。

典型的调用链如下：
1. 当Channel上发生事件（如数据读取事件）时，事件被委托给Channel关联的EventLoop。
2. EventLoop从Channel的事件队列中取出事件。
3. EventLoop将事件传递给Channel关联的Pipeline的头部Handler。
4. 从头部Handler开始，Pipeline按照顺序将事件传递给每个Handler进行处理。
5. 每个Handler可以处理事件、修改事件或传递事件给下一个Handler。
6. 事件流动到Pipeline的尾部Handler，然后返回。
7. 如果事件需要回应，Pipeline将回应事件从尾部Handler开始，逆向传播到头部Handler，然后返回给Channel。
8. EventLoop将回应事件发送回Channel的对等方。

这个调用链允许每个组件在事件处理过程中执行特定的操作，同时保持了一定的顺序性和一致性。这个模型使得Netty能够高效地处理网络事件，实现了高性能的网络应用程序。不过需要注意，实际的事件流动过程可能会更加复杂，因为可能会涉及到多个Channel、多个EventLoop等。
## 各组件的常用方法
1. **EventLoop（事件循环）**：
    - `register(Channel channel)`：将一个Channel注册到EventLoop上，开始监听该Channel上的事件。
    - `submit(Callable<V> task)`：将一个任务提交给EventLoop执行。
    - `schedule(Runnable command, long delay, TimeUnit unit)`：延迟执行一个任务。
    - `execute(Runnable command)`：执行一个Runnable任务。
    - `shutdownGracefully()`：优雅地关闭EventLoop，等待所有任务执行完毕后关闭。
2. **Channel（通道）**：
    - `write(Object msg)`：将数据写入通道。
    - `close()`：关闭通道。
    - `isActive()`：检查通道是否处于活动状态。
    - `localAddress()`：获取本地地址。
    - `remoteAddress()`：获取远程地址。
    - `config()`：获取通道的配置信息。
    - `pipeline()`：获取与通道关联的Pipeline。
3. **Pipeline（管道）**：
    - `addLast(String name, ChannelHandler handler)`：向Pipeline尾部添加一个Handler。
    - `addFirst(String name, ChannelHandler handler)`：向Pipeline头部添加一个Handler。
    - `remove(ChannelHandler handler)`：从Pipeline中移除指定的Handler。
    - `get(String name)`：根据名称获取Pipeline中的Handler。
    - `fireXXX()`：触发特定类型的事件，将事件从头部开始流经Pipeline。
4. **Handler（处理器）**：
    - `channelRead(ChannelHandlerContext ctx, Object msg)`：处理入站数据读取事件。
    - `write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)`：处理出站数据写入事件。
    - `exceptionCaught(ChannelHandlerContext ctx, Throwable cause)`：处理异常事件。
    - `userEventTriggered(ChannelHandlerContext ctx, Object evt)`：处理用户自定义事件。
    - `channelActive(ChannelHandlerContext ctx)`：处理通道激活事件。
    - `channelInactive(ChannelHandlerContext ctx)`：处理通道失活事件。
    - `handlerAdded(ChannelHandlerContext ctx)`：当Handler被添加到Pipeline时调用。
    - `handlerRemoved(ChannelHandlerContext ctx)`：当Handler从Pipeline中移除时调用。