# Maven
## 基本概念
### 仓库
用于存储资源，包含各种jar包
分类：
**本地仓库**:自己电脑上存储资源的仓库,连接远程仓库获取资源
**远程仓库**:非本机电脑上的仓库，为本地仓库提供资源，分为中央仓库和私服
中央仓库: Maven团队维护，存储所有资源的仓库
私服:部门/公司范围内存储资源的仓库，从中央仓库获取资源
**私服的作用**:
保存具有版权的资源,包含购买或自主研发的jar
中央仓库中的jar都是开源的，不能存储具有版权的资源
一定范围内共享资源，仅对内部开放，不对外共享
### 坐标
Maven中的坐标用于描述仓库中资源的位置
Maven坐标主要组成：
groupld:定义当前Maven项目隶属组织名称(通常是域名反写，例如: org.mybatis)
artifactld:定义当前Maven项目名称(通常是模块名称，例如CRM、SMS)
version:定义当前项目版本号
（packaging:定义该项目的打包方式）
Maven坐标的作用：
使用唯一标识，唯一性定位资源位置，通过该标识可以将资源的识别与下载工作交由机器完成
### 仓库配置
在maven的下载路径下有一个setting文件，可以更改一些基础设置，比如本地仓库的存储位置，以及配置阿里镜像仓库，即从阿里的仓库中获取资源而非中央仓库，这样快一点
## Maven的工程目录结构
![[Pasted image 20230822152137.png]]
大概了解一下，现在一般是在idea中直接创建maven工程或spring工程
## 依赖管理
### 依赖配置
依赖是指当前项目运行所需的jar，一个项目可以设置多个依赖，这些依赖一般来自于中心仓库（私服），是前人或同事写好的jar包或工具类
![[Pasted image 20230822152553.png]]
### 依赖传递
在引入一个新的jar包时，这个jar包可能依赖其它的jar包，在导入这个jar包时，会将它的所有依赖也一起导入，这就是依赖的传递性
直接依赖：在当前项目中通过依赖配置建立的依赖关系
间接依赖：被依赖的资源如果依赖其它资源，当前项目间接依赖其它资源
这有时会导致依赖传递冲突问题，也就是可能不同级的依赖相同但版本号不同，应遵守以下原则：
路径优先:当依赖中出现相同的资源时，层级越深，优先级越低，层级越浅，优先级越高
声明优先:当资源在相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后的
特殊优先:当同级配置了相同资源的不同版本，后配置的覆盖先配置的

### 可选依赖
可选依赖指对外隐藏当前所依赖的资源（但仍在使用）
```
<dependency>
	<groupId>junit</groupId>
	<artifactId>junit</artifactId>
	<version>4.12</version>
	<optional>true</optional>
</dependency>
```
### 排除依赖
排除依赖指不再使用当前所指的资源
```
<dependency>
	<groupId>junit</groupId>
	<artifactId>junit</artifactId>
	<version>4.12</version>
	<exalusions>
		<exclusion>
			<groupId>org.hamcrest</groupId>
			<artifactId>hamcrest-core</artifactId>
		</exclusion>
	</exclusions>
</dependency>
```
### 依赖范围
依赖的jar默认情况可以在任何地方使用，可以通过scope标签设定其作用范围
作用范围：
主程序范围有效(main文件夹范围内)
测试程序范围有效(test文件夹范围内)
是否参与打包(package指令范围内)
![[Pasted image 20230822153502.png]]
### 循环依赖
1. **优化模块设计**： 首先，考虑你的模块设计是否合理。循环依赖通常是模块之间划分不清晰所导致的。尽量遵循单一职责原则，将模块按照功能分割，减少模块之间的直接依赖。
2. **拆分和合并模块**： 如果发现存在循环依赖，考虑将其中一个或多个模块进行拆分或合并，以消除循环依赖。有时，将功能合并到一个模块中，或者将一些共享的功能抽离成一个独立的模块，可以帮助解决循环依赖问题。
3. **使用接口和抽象**： 如果模块之间需要互相调用，尽量通过接口或抽象类来定义依赖关系，而不是直接依赖具体实现。这可以减少循环依赖的风险。
4. **Maven 中的 `<dependencyManagement>`**： 如果循环依赖是由于版本问题引起的，可以使用 Maven 的 `<dependencyManagement>` 部分来集中管理依赖的版本，以确保一致性。
5. **提取接口模块**： 为了解决循环依赖，你可以创建一个独立的接口模块，其中定义了所有模块之间的接口。然后各个模块可以依赖于这个接口模块，而不会产生循环依赖。
6. **调整模块依赖关系**： 在 `<dependencies>` 部分中，可以明确声明模块的依赖关系和作用域，以便更好地控制依赖。
7. **检查插件和目标**： 有时，循环依赖可能是由于插件的配置或目标的执行引起的。检查是否有插件或目标的配置引发了循环依赖。
8. **使用模块路径**： 如果使用 Java 9 及更高版本，可以尝试使用模块路径来隔离模块，避免循环依赖。
9. **重新考虑项目结构**： 如果循环依赖问题无法通过上述方法解决，可能需要重新审视项目结构和模块之间的关系，进行更大范围的重构。
## 生命周期与插件

### 生命周期
生命周期指maven对项目的阶段的管理，一般分为三类：
clean：清理工作
default：核心工作，例如编译，测试，打包，部署等
site：产生报告，发布站点等
在执行某个生命周期时，会默认将这个生命周期前的所有生命周期全部执行完成，除非指定不执行某个生命周期
### 插件
插件与生命周期内的阶段绑定，在执行到对应生命周期时执行对应的插件功能
内置插件：默认maven在各个生命周期上绑定有预设的功能
自定义插件：通过插件可以自定义其他功能，如果内置插件无法满足特定需求，可以创建自定义插件。自定义插件通常使用 Java 编写，通过继承 Maven 插件框架来实现。
```
    <build>
        <plugins>
            <plugin>
                <groupId>com.example</groupId> <!-- 插件的 Group ID -->
                <artifactId>my-custom-plugin</artifactId> <!-- 插件的 Artifact ID -->
                <version>1.0.0</version> <!-- 插件的版本 -->
                <executions>
                    <execution>
                        <goals>
                            <goal>custom-goal</goal> <!-- 自定义插件的目标（Goal） -->
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
```
idea中执行的生命周期：
1. **clean**： 清理项目构建生成的目录和文件，包括 `target` 目录。
2. **compile**：编译项目的源代码，生成字节码文件。
3. **test**： 运行项目的单元测试。
4. **package**： 将编译后的代码打包成可分发的格式，如 JAR、WAR 或 EAR。
5. **install**：将项目构建结果安装到本地 Maven 仓库，以供其他项目引用。
6. **deploy**: 将构建结果部署到远程 Maven 仓库，以便其他项目或团队访问。
7. **site**: 生成项目的站点文档和报告，如代码覆盖率、测试报告等。
## 分模块开发
分模块开发思想是将一个大型应用程序分解为更小、更易管理的模块，每个模块负责不同的功能或组件。每个模块都可以独立开发、测试和部署。如在web编程中，将实体类pojo，业务层service，数据层dao，控制层controller都分别设置为一个独立的模块
这种方式有许多好处：
1. **模块化**：将应用程序分为模块使得代码更加模块化和组织有序，容易理解和维护。
2. **独立开发**：开发人员可以专注于自己负责的模块，而不必关心整个应用程序。
3. **并行开发**：不同模块可以并行开发，提高了开发效率。
4. **重用性**：可以更轻松地将模块复用在其他项目中，从而提高了代码的重用性。
5. **测试**：每个模块都可以独立测试，减少了单一应用程序中的复杂度。
6. **扩展性**：添加新功能时，可以更容易地将新模块集成到现有应用程序中。
### 模块聚合
模块聚合是将分开开发的模块汇总在一起，形成一个完整的应用程序。通常情况下，会有一个父级 POM（Project Object Model），其中包含所有模块的定义和依赖关系。父级 POM 也可以定义构建的顺序和版本控制策略。对父级模块进行操作时，所有子模块也会进行相同的操作
![[Pasted image 20230822162539.png]]
### 依赖继承
 在父工程中定义依赖管理，在子工程中定义依赖关系，无需声明依赖版本，版本参照父工程中依赖的版本
```
<! --声明此处进行依赖管理-->
<dependencyManagement>
	<!--具体的依赖-->
	<dependencies>
		<!--spring环境-->
		<dependency>
			<groupId>org. springframework</ groupId>
			<artifactId>spring-context</artifactId>
			<version>5.1.9.RELEASE</version>
		</dependency>
	<dependencies>
<dependencyManagement>
```
### 继承与聚合对比
作用
聚合用于快速构建项目
继承用于快速配置
相同点:
聚合与继承的pom.xml文件打包方式均为pom，可以将两种关系制作到同一个pom文件中
聚合与继承均属于设计型模块，并无实际的模块内容
不同点:
聚合是在当前模块中配置关系，聚合可以感知到参与聚合的模块有哪些
继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己
### 属性
在pom文件中可以通过property标签自定义属性，相当于define，之后用到时就可以用#{属性名}直接引用，修改属性中的值就可以同时修改所有引用处的值
属性分为自定义属性，内置属性，setting属性，java系统属性，环境变量属性
![[Pasted image 20230822163251.png]]
## 版本管理
**工程版本**
SNAPSHOT(快照版本)
项目开发过程中，为方便团队成员合作，解决模块间相互依赖和时时更新的问题，开发者对每个模块进行构建的时候，输出的临时性版本叫快照版本（(测试阶段版本)，快照版本会随着开发的进展不断更新
RELEASE(发布版本)
项目开发到进入阶段里程碑后，向团队外部发布较为稳定的版本，这种版本所对应的构件文件是稳定的，即便进行功能的后续开发，也不会改变当前发布版本内容，这种版本称为发布版本
**工程版本号约定**
约定规范:
1.<主版本>.<次版本>,<增量版本><里程碑版本>
2.主版本:表示项目重大架构的变更，如: spring5相较于spring4的迭代
3.次版本:表示有较大的功能增加和变化，或者全面系统地修复漏洞
4.增量版本:表示有重大漏洞的修复
5.里程碑版本:表明一个版本的里程碑（版本内部)。这样的版本同下一个正式版本相比，相对来说不是很稳定，有待更多的测试
范例:
5.1.9.RELEASE
## 资源加载属性值
如果想任意配置文件中加载pom文件中定义的属性，可以在配置文件中使用 ${属性名}来调用，同时，需要在pom文件中配置开启此方式，反则编译时无法获取到属性值
```
<!--配置资源文件对应的信息-->
<resources>
	<resource>
		<!-设定配置文件对应的位置目录，支持使用属性动态设定路径-->
		<directory>${project.basedir)/src/main/resources</directory>
		<!--开启对配置文件的资源加载过滤-->
		<filtering>true</filtering>
	</ resource>
<resources>
```
## 跳过测试
1.使用命令跳过测试(执行的指令生命周期必须包含测试环节)
```
mvn 某个指令 -D skipTests
```
2.使用界面操作跳过测试
![[Pasted image 20230822164623.png]]
3.使用配置跳过测试（还可以包含或排除某些测试用例）
```
<plugin>
	<artifactId>maven-surefire-plugin</artifactId>
	<version>2.22.1</version>
	<configuration>
	<skipTests>true</skipTests><!--设置跳过测试-->
	<includes> <!--包含指定的测试用例-->
		<inalude>**/User*Test.java</include>
	</includes>
	<excludes><!--排除指定的测试用例-->
		<exclude>**/User*Testcase.java</exclude>
	</excludes>
</configuration></plugin>

```
## 私服的上传和访问
![[Pasted image 20230822164941.png]]

# git
Git 是一个分布式版本控制系统，用于跟踪软件开发过程中的代码变更。它允许多个开发者协同工作，同时记录代码的变更历史，管理不同版本的代码库，以及轻松地创建分支和合并代码。
## 基础概念
以下是与 Git 相关的一些关键概念和命令：
1. **仓库（Repository）**：仓库是包含项目及其所有文件的目录，同时还包括了代码变更的历史记录。
2. **克隆（Clone）**：要开始使用一个 Git 仓库，通常会使用 `git clone` 命令将远程仓库克隆到本地计算机上
3. **提交（Commit）**：提交是在特定时间点对你的更改进行快照。你可以使用 `git commit` 命令将更改保存到本地仓库。
4. **分支（Branch）**：分支是仓库内的一个独立开发线。它允许你在不影响主要代码库的情况下开发功能或修复问题。可以使用 `git branch` 创建分支，使用 `git checkout` 在不同分支之间切换。
5. **合并（Merge）**：合并将一个分支的更改合并到另一个分支中。使用 `git merge` 命令将源分支的更改集成到目标分支中。
6. **拉取（Pull）**：拉取是从远程仓库获取更改并将其整合到本地仓库的过程。这通常用于保持本地仓库与远程仓库同步。你可以使用 `git pull` 进行拉取操作。
7. **推送（Push）**：推送将本地的提交发送到远程仓库。这是与他人共享更改的方式。使用 `git push` 进行推送操作。
8. **远程（Remote）**：远程是对远程仓库的引用，通常托管在平台如 GitHub、GitLab 或 Bitbucket 上。可以使用 `git remote` 命令添加、删除或管理远程仓库。
9. **状态（Status）**：`git status` 命令显示仓库的当前状态，包括已经进行但尚未提交的更改。
10. **差异（Diff）**：`git diff` 命令显示两个版本之间的差异，帮助你理解所做的更改。
## 常用命令
  
当涉及到 Git 常用命令时，以下是一些可能会用到的一些命令及其简要描述：
1. `git init`：在当前目录初始化一个新的 Git 仓库。
2. `git clone <URL>`：从远程仓库克隆代码到本地。
3. `git add <file>`：将文件的更改添加到暂存区。
4. `git commit -m "message"`：将暂存区的更改提交到本地仓库。
5. `git status`：查看当前仓库的状态，包括未提交的更改。
6. `git diff`：显示当前工作目录中的更改。
7. `git branch`：列出所有本地分支，显示当前所在分支。
8. `git checkout <branch>`：切换到指定分支。
9. `git merge <branch>`：将指定分支的更改合并到当前分支。
10. `git pull`：从远程仓库拉取最新更改。
11. `git push`：将本地更改推送到远程仓库。
12. `git remote add <name> <URL>`：添加一个远程仓库。
13. `git log`：查看提交历史记录。
14. `git reset <file>`：从暂存区撤销文件的更改。
15. `git revert <commit>`：创建一个新提交，撤销指定提交的更改。
16. `git stash`：将当前未提交的更改暂存起来，以便在切换分支时使用。
17. `git tag <tagname>`：创建一个标签，用于标记某个特定的提交。
## git的工作原理
### 工作区域
Git本地有三个工作区域∶工作目录(Working Directory )、暂存区(Stage/ndex)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下∶
![[Pasted image 20230822165257.png]]
Workspace :工作区，就是平时存放项目代码的地方
Index / Stage:暂存区，用于临时存放改动，事实上它只是一个文件，保存即将提交到文件列表信息
Repository :仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交的所有版本的数据。其中HEAD指向最新放入仓库的版本
### 工作流程
1、在工作目录中添加、修改文件;
2.将需要进行版本管理的文件放入暂存区域;
3.将暂存区域的文件提交到git仓库。
因此，git管理的文件有三种状态：已修改，已暂存，已提交
## 关于分支
git是一个帮助多人协同合作的工具，由于个人之间的工作不同，项目代码势必会在同一基础上进行不同的修改，这个同一基础就是master主分支，要对master进行修改，一般要新建一个分支，对master进行不同修改后得到的不同分支进行合并时，一般会由git判断是否存在冲突，这时，Git 不能自动决定应该选择哪个更改，因为它无法确定哪个更改是正确的。在这种情况下，Git 会将冲突标记在文件中，然后需要开发者手动解决冲突，冲突解决后，可以将合并后的这个新的分支设置为新的master
解决冲突的一般步骤是：
1.执行`git pu11`以获取远程分支的最新更改。
2.Git将会提示存在冲突的文件，需要在这些文件中手动编辑并解决冲突。
3.编辑后的文件需要保存，然后使用`git add`将文件标记为已解决。
4.最后，运行`git commit`来提交解决冲突的更改。

## 关于一些常见问题
1. **Git的原理和工作流程**： Git 是一种分布式版本控制系统，它的核心原理是基于快照（snapshot）。每次提交（commit）都会创建一个文件和目录的快照，而不是保存文件之间的差异。Git 的工作流程通常包括以下步骤：
    - **克隆（Clone）**：从远程仓库复制项目到本地，创建一个本地仓库。
    - **工作目录（Working Directory）**：在本地仓库中，你可以在工作目录中修改文件。
    - **暂存区（Staging Area）**：将工作目录中的修改添加到暂存区，为下一次提交做准备。
    - **提交（Commit）**：从暂存区中创建一个快照，将其保存到版本历史中。
    - **分支（Branch）**：可以创建分支来在不同功能上开展并行开发，每个分支都有自己的工作目录、暂存区和提交历史。
    - **合并（Merge）**：将不同分支上的修改合并到一起，形成一个新的提交。
    - **推送（Push）**：将本地提交推送到远程仓库，与团队共享。
    - **拉取（Pull）**：从远程仓库获取最新的变更，包括其他人的提交。
2. **版本控制系统**： 版本控制系统（Version Control System，VCS）是一种用于追踪和管理文件版本和变更历史的工具。它允许多人协同开发、追踪代码变化、回溯历史、分支和合并等。VCS 的主要目的是使开发团队能够更有效地协同工作，减少错误和冲突，并为项目提供详细的版本历史。
3. **git fetch和git pull命令的区别**：
    - `git fetch`：从远程仓库获取最新的提交和分支信息，但不会自动合并或更新你的工作目录。它会将获取的内容存储在本地仓库的远程跟踪分支中。
        
    - `git pull`：执行两个操作，首先，它会从远程仓库拉取最新的提交并合并到当前分支，然后更新你的工作目录。这相当于执行了 `git fetch` 后紧接着的 `git merge`。
4. **git rebase和git merge命令的区别**：
    - `git merge`：将一个分支的更改合并到另一个分支。合并会创建一个新的提交节点，记录两个分支的历史交汇点。
    - `git rebase`：将一个分支上的更改在另一个分支的基础上重新应用。它将当前分支上的提交逐个应用到目标分支的顶部，创造更线性的提交历史。
5. **Git Flow**： Git Flow 是一种流行的 Git 分支管理工作流，它提供了一套规范的分支命名和管理策略。它包括主分支（master）、开发分支（develop）、功能分支（feature）、发布分支（release）、修复分支（hotfix）等。Git Flow 的好处在于使协同开发更有条理，促进版本控制和发布的流程化，降低冲突和错误。
6. **暂存区**： 暂存区是 Git 版本控制系统的一个重要概念。在进行提交之前，你可以将工作目录中的修改（包括新增、修改和删除的文件）添加到暂存区。暂存区允许你控制哪些更改应该包含在下一次提交中。这使你能够构建精细的提交，准备提交前进行检查，避免错误和混乱的提交。
    Git 需要暂存区的存在，因为它提供了更多的控制权和准备提交的灵活性。你可以选择性地将不同文件的修改添加到暂存区，从而创建更清晰、有序的提交历史。
7. **控制某些文件不被提交**： 你可以使用`.gitignore`文件来控制哪些文件或目录在提交时被忽略。在项目根目录下创建或编辑`.gitignore`文件，然后列出你希望忽略的文件、目录、通配符等。这样，这些文件就不会出现在提交中。
8. **提交冲突的情况和解决方法**： 冲突通常发生在以下情况：
    - 多人同时修改同一行或相邻行的代码。
    - 合并分支时，两个分支有相同文件的不同修改。
    解决冲突的步骤：
    - 运行 `git status` 查看冲突文件。
    - 打开冲突文件，在文件中可以看到类似于 `<<<<<<< HEAD`、`=======` 和 `>>>>>>> branch_name` 的标记，这是冲突的标志。
    - 手动编辑文件，保留需要的代码部分，删除冲突标记和无关的部分。
    - 保存文件，然后运行 `git add` 将冲突文件标记为已解决。
    - 运行 `git commit` 提交解决冲突后的修改。
9. **恢复错误的代码或删除的文件**：
    - 对于已提交的错误代码，可以通过创建新的提交来修复。你可以修改代码，然后提交一个新的修复提交。
    - 对于已删除的文件，如果你没有提交删除操作，可以使用 `git checkout` 命令来还原文件，例如：`git checkout filename`。
10. **项目代码管理的方法**：
    - 使用版本控制系统，如 Git。
    - 遵循分支管理策略，如 Git Flow，以便有条理地管理功能开发、测试和发布。
    - 使用代码审查来保证代码质量。
    - 使用持续集成和持续交付工具，确保代码的集成和交付过程自动化、稳定和可重复。
    - 鼓励团队成员遵循一致的编码风格和最佳实践。
11. **防止错误的代码提交**：
    - 使用代码审查：通过审查他人的代码，可以发现和纠正错误。
    - 使用自动化测试：编写自动化测试用例来检查代码是否正常工作。
    - 使用持续集成：集成和自动化测试可以在提交之前自动运行，减少错误的机会。
    - 使用预提交挂钩（pre-commit hooks）：可以设置钩子，在提交前运行特定的脚本来检查代码是否符合规范。